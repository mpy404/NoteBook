{"./":{"url":"./","title":"Gitbook的搭建","keywords":"","body":"Gitbook的搭建 安装node.js【我用的node10.23版本】 安装好后cmd下输入node -v npm -v查看是否安装成功 npm安装gitbook cmd下输入npm install gitbook-cli -g 安装好后输入 gitbook -V 【可能还会安装，可能是因为node新版本的一些问题，倒退一个或两个版本就可以解决】 找到合适的地方创建笔记 在笔记目录下打开cmd，输入gitbook init【初始化】 成功的话会生成两个文件README.md和SUMMARY.md 输入gitbook serve会开启此服务，提醒浏览器输入localhost:4000来查看文档 再次输入gitbook build【编译】会出现_book，可以使用该命令生成网页而不开启服务 配置book.jsom { \"title\" : \"Java\", \"author\" : \"Mpy\", \"language\" : \"zh-hans\", \"gitbook\": \"3.x.x\", \"plugins\": [ \"back-to-top-button\", // 回到顶部 \"expandable-chapters\", // 可扩展章节 \"code\", // 添加行号 复制按钮 \"-lunr\", \"-search\", \"search-pro\", // 高级搜索 \"github\", // 添加github图标 \"splitter\", // 侧边栏宽度调节 \"popup\", // 新页面查看大图 \"ancre-navigation\" // 页面右上角悬浮导航以及回到顶部按钮 ] } "},"NoteBook/java基础/java基础.html":{"url":"NoteBook/java基础/java基础.html","title":"java基础","keywords":"","body":"IDEA常用快捷键 ctrl + alt + l 快速整理代码 ctrl + alt +空格 代码提示 ctrl + alt +v 快速设置变量 alt +insert 快速创建构造方法set/get方法等 JDK、JRE、JVM JDK （开发环境） 包含 jre（运行时环境）和 开发工具 jre （运行时环境） 包含 jvm（保证java跨平台） 和 核心类库 注释 单行注释 // 内容 多行注释 /内容/ 文档注释 / 内容 / 方法声明的正确性 @Override 命名规则 小驼峰式（方法、变量） 标识符是一个单词的时候，首字母小写(name) 标识符有多个单词组成的时候，第一个单词首字母小写，其他单词的首字母大写(studebtName) 大驼峰式（类） 标识符是一个单词的时候大写（Class） 标识符由多个单词组成的时候所有的单词首字母都要大写(ClassStudent) "},"NoteBook/java基础/变量与常亮.html":{"url":"NoteBook/java基础/变量与常亮.html","title":"变量与常亮","keywords":"","body":"常量与变量 常量 空常量不能直接输出 字符串常量 用双引号括起来的量 \"我\"、\"A\" 整数常量 不带小数的数字 12、-12 小数常量 带小数的数字 12.12、-1.2 字符常量 用单引号括起来的内容 'A'、'我' 布尔常量 布尔值，表示真假 只有两个值：true、false 空常量 一个特殊的值 值是：null 变量 在程序运行中可以发生改变的量 变量名、数据类型、变量值 "},"NoteBook/java基础/数据类型.html":{"url":"NoteBook/java基础/数据类型.html","title":"数据类型","keywords":"","body":"数据类型 计算机存储设备的最小单元叫\"位（bit）\"，又称之为比特位，用小写字母\"b\" 计算机中最小存储单元是\"字节（byte）\"，用大写字母\"B\" 字节是有连续的8个位组成 1B = 8b 1KB = 1024B 1MB = 1024KB 1GB = 1024MB 1TB = 1024GB 基本数据类型 E+38表示乘以10的38次方、E-45表示乘以10的-45次方 整数默认是int类型、浮点数默认是double类型 数值型 整数 byte 内存占用：1byte byte 数据类型是8位、有符号的，以二进制补码表示的整数； byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一 取值范围：-128~127 最小值是 -128（-2^7） 最大值是 127（2^7-1） 默认值是 0 例子 byte a = 100，byte b = -50 short 内存占用：2byte short 数据类型是 16 位、有符号的以二进制补码表示的整数 Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一 取值范围：-32768~32767 最小值是 -32768（-2^15） 最大值是 32767（2^15 - 1） 默认值是 0 例子 short s = 1000，short r = -20000 int 内存占用：4byte int 数据类型是32位、有符号的以二进制补码表示的整数 取值范围：-2的31次方到2的31次方-1 最小值是 -2,147,483,648（-2^31） 最大值是 2,147,483,647（2^31 - 1） 一般地整型变量默认为 int 类型 默认值是 0 例子 int a = 100000, int b = -200000 long 内存占用：8byte long 数据类型是 64 位、有符号的以二进制补码表示的整数 这种类型主要使用在需要比较大整数的系统上 取值范围：-2的63次方到2的63次方-1 最小值是 -9,223,372,036,854,775,808（-2^63） 最大值是 9,223,372,036,854,775,807（2^63 -1） 默认值是 0L 例子 long a = 100000L，Long b = -200000L \"L\"理论上不分大小写，但是若写成\"l\"容易与数字\"1\"混淆，不容易分辩。所以最好大写。 浮点数 float 内存占用：4byte float 在储存大型浮点数组的时候可节省内存空间 float 数据类型是单精度、32位、符合IEEE 754标准的浮点数 浮点数不能用来表示精确的值，如货币 取值范围 正数：1.401298E-45 — 3.402823E+38 负数：-3.402823E+38 — -1.401298E-45 默认值是 0.0f 例子 float f1 = 234.5f double 浮点数的默认类型为double类型 double类型同样不能表示精确的值，如货币 内存占用：8byte double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数 取值范围 正数：4.9000000E-324~1.797693E+308 负数：-1.797693E+308~-4.9000000E-324 默认值是 0.0d 例子 double d1 = 123.4 字符 char 内存占用：2byte char类型是一个单一的 16 位 Unicode 字符 char 数据类型可以储存任何字符 取值范围：0-65535 最小值是 \\u0000（即为0） 最大值是 \\uffff（即为65,535） 例子 char letter = 'A' 非数值型 布尔 boolean 内存占用：1byte（boolean数据类型表示一位的信息；） 取值范围：true、false 默认值是 false 例子 boolean one = true public static void main(String[] args) { // byte System.out.println(\"基本类型：byte 二进制位数：\" + Byte.SIZE); System.out.println(\"包装类：java.lang.Byte\"); System.out.println(\"最小值：Byte.MIN_VALUE=\" + Byte.MIN_VALUE); System.out.println(\"最大值：Byte.MAX_VALUE=\" + Byte.MAX_VALUE); System.out.println(); // short System.out.println(\"基本类型：short 二进制位数：\" + Short.SIZE); System.out.println(\"包装类：java.lang.Short\"); System.out.println(\"最小值：Short.MIN_VALUE=\" + Short.MIN_VALUE); System.out.println(\"最大值：Short.MAX_VALUE=\" + Short.MAX_VALUE); System.out.println(); // int System.out.println(\"基本类型：int 二进制位数：\" + Integer.SIZE); System.out.println(\"包装类：java.lang.Integer\"); System.out.println(\"最小值：Integer.MIN_VALUE=\" + Integer.MIN_VALUE); System.out.println(\"最大值：Integer.MAX_VALUE=\" + Integer.MAX_VALUE); System.out.println(); // long System.out.println(\"基本类型：long 二进制位数：\" + Long.SIZE); System.out.println(\"包装类：java.lang.Long\"); System.out.println(\"最小值：Long.MIN_VALUE=\" + Long.MIN_VALUE); System.out.println(\"最大值：Long.MAX_VALUE=\" + Long.MAX_VALUE); System.out.println(); // float System.out.println(\"基本类型：float 二进制位数：\" + Float.SIZE); System.out.println(\"包装类：java.lang.Float\"); System.out.println(\"最小值：Float.MIN_VALUE=\" + Float.MIN_VALUE); System.out.println(\"最大值：Float.MAX_VALUE=\" + Float.MAX_VALUE); System.out.println(); // double System.out.println(\"基本类型：double 二进制位数：\" + Double.SIZE); System.out.println(\"包装类：java.lang.Double\"); System.out.println(\"最小值：Double.MIN_VALUE=\" + Double.MIN_VALUE); System.out.println(\"最大值：Double.MAX_VALUE=\" + Double.MAX_VALUE); System.out.println(); // char System.out.println(\"基本类型：char 二进制位数：\" + Character.SIZE); System.out.println(\"包装类：java.lang.Character\"); // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台 System.out.println(\"最小值：Character.MIN_VALUE=\" + (int) Character.MIN_VALUE); // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台 System.out.println(\"最大值：Character.MAX_VALUE=\" + (int) Character.MAX_VALUE); } 基本类型：byte 二进制位数：8 包装类：java.lang.Byte 最小值：Byte.MIN_VALUE=-128 最大值：Byte.MAX_VALUE=127 基本类型：short 二进制位数：16 包装类：java.lang.Short 最小值：Short.MIN_VALUE=-32768 最大值：Short.MAX_VALUE=32767 基本类型：int 二进制位数：32 包装类：java.lang.Integer 最小值：Integer.MIN_VALUE=-2147483648 最大值：Integer.MAX_VALUE=2147483647 基本类型：long 二进制位数：64 包装类：java.lang.Long 最小值：Long.MIN_VALUE=-9223372036854775808 最大值：Long.MAX_VALUE=9223372036854775807 基本类型：float 二进制位数：32 包装类：java.lang.Float 最小值：Float.MIN_VALUE=1.4E-45 最大值：Float.MAX_VALUE=3.4028235E38 基本类型：double 二进制位数：64 包装类：java.lang.Double 最小值：Double.MIN_VALUE=4.9E-324 最大值：Double.MAX_VALUE=1.7976931348623157E308 基本类型：char 二进制位数：16 包装类：java.lang.Character 最小值：Character.MIN_VALUE=0 最大值：Character.MAX_VALUE=65535 引用数据类型 类 class 接口 interface 数组 [] 类型转换 自动类型转换 表示把一个数据范围小的数值或变量赋值给另一个表示数据范围大的额变量 byte自动转char不成功，类型不兼容 强制类型转化 把一个数据表示范围大的数值或变量赋值给另一个表示数据范围小的变量 目标数据类型 变量名 = (目标数据类型)值或者变量 int a = (int)99.123 数据范围从小到大顺序 graph LR; byte--> short; byte-->char; short--> int char-->int int --> long; long --> float; float --> double; "},"NoteBook/java基础/运算符.html":{"url":"NoteBook/java基础/运算符.html","title":"运算符","keywords":"","body":"运算符 \"==\" 比较时，基本数据类型是数据值是否相同，引用类型是地址值是否相同 算术运算符 +、-、*、/、% /：整数除法只会得到整数，不会得到小数，要想得到小数，必须有浮点数参加 算术表达式中包含多个基本数据类型的值得时候，整个算术表达式的类型会自动进行提升 byte类型、short类型、char类型将被提升为int类型 等级顺序： graph LR; byte --> int; short --> int; char --> int; int --> long; long --> float; float --> double; char a = 'a'; int b = 10; System.out.println(a+b);会报错 char的数据类型会被提升为int类型，所以必须得由一个int类型的变量接受，才能打印 int c = a+ b; 赋值运算符 =、+=、-=、/=、%= 逻辑运算符 逻辑与： &：无论左边真假，右边都会执行 短路与： &&：如果左边为真，右边执行，如果左边位假，右边不执行 逻辑或： |：无论左边真假，右边都会执行 短路或： ||：左边为假，右边执行，左边为真，右边不执行 异或： ^：相同为false，不同为true 非： ！：和正常结果相反 三元运算符 关系表达式 ? 表达式1 : 表达式2; 如果关系表达式的值为true表达式1的值就是运算结果 如果关系表达式的值为false表达式2的值就是运算结果 public class Main { public static void main(String[] argv) { int denom = 10; int num = 4; double ratio; ratio = denom == 0 ? 0 : num / denom; System.out.println(\"ratio = \" + ratio); } } // 结果：ratio:0.0 // /：整数除法只会得到整数，不会得到小数，要想得到小数，必须有浮点数参加 "},"NoteBook/java基础/判断和循环.html":{"url":"NoteBook/java基础/判断和循环.html","title":"判断和循环","keywords":"","body":"if 和 switch import java.util.Scanner; public class Demo01 { public static void main(String[] args){ Scanner sc = new Scanner(System.in); System.out.print(\"输入数字1：\"); int height_1 = sc.nextInt(); System.out.print(\"输入数字2：\"); int height_2 = sc.nextInt(); if(height_1 >height_2){ System.out.println(1); }else if(height_1 switch的表达式取值为byte、short、int、char，JDK5以后可以枚举，JDK7以后可以使String case后面的值是和表达式进行比较 break表示退出 default表示所有情况不匹配的时候，就处理该内容 public class Demo2 { public static void main(String[] args) { switch(表达式){ case 值1: 语句体; break; case 值2: 语句体; break; default: 语句体; break; } } } import java.util.Scanner; public class Demo2 { public static void main(String[] args) { Scanner sc_1 = new Scanner(System.in); int num_1 = sc_1.nextInt(); Scanner sc_2 = new Scanner(System.in); int num_2 = sc_2.nextInt(); int num_3 = num_1 - num_2; switch(num_3){ case 1: System.out.println(num_3); break; case 2: System.out.println(num_3); break; case 3: System.out.println(num_3); default: System.out.print(\"请输入争取的数字\"); break; } } } "},"NoteBook/java基础/集合.html":{"url":"NoteBook/java基础/集合.html","title":"集合","keywords":"","body":"集合 特点 提供一种存储空间可变的存储模型，存储的数据容量可以发生改变 ArraayList 可调节的数组实现 是一种特殊的数据类型，泛型 构造方法 创建一个空的集合对象 ArrayList array = new ArrayList<>(); 将指定的元素追加到此集合的末尾 array.add(\"Hello\"); 在此集合中的指定位置插入指定的元素 array.add(1, \"World\"); 常用方法 ArrayList array = new ArrayList<>(); 在此集合中的指定位置插入指定的元素 array.add(1, \"World\"); 删除指定的元素，返回删除是否成功 array.remove(\"删除的元素\"); 删除指定索引处的元素，返回被删除的元素 array.remove(删除元素的索引); 修改制定所引出的元素，返回被修改的元素 array.set(1, \"aa\"); 返回指定所引出的元素 array.get(2); 返回集合中的元素的个数 array.size(); 遍历集合 package demo2; import java.util.ArrayList; public class Demo5 { public static void main(String[] args) { ArrayList array = new ArrayList<>(); array.add(\"甲\"); array.add(\"乙\"); array.add(\"丙\"); array.add(\"丁\"); System.out.println(array); for (int i = 0; i 学生教务系统案例 学生类 ```java public class Student { private String id; private String age; private String name; private String address; public Student(){} public Student(String id, String name, String age, String address){ this.id = id; this.name = name; this.age = age; this.address = address; } // 学号 public void setId(String id){ this.id = id; } public String getId(){ return id; } // 名字 public void setName(String name){ this.name = name; } public String getName(){ return name; } // 年龄 public void setAge(String age){ this.age = age; } public String getAge(){ return age; } // 居住地 public void setAddress(String address){ this.address = address; } public String getAddress(){ return address; } } - 系统实现 ```java import java.util.ArrayList; import java.util.Scanner; public class Demo { public static void main(String[] args) { ArrayList array = new ArrayList<>(); while (true){ System.out.println(\"----------欢迎登陆系统----------\"); System.out.println(\"\\t\\t1. 添 加 学 生\"); System.out.println(\"\\t\\t2. 删 除 学 生\"); System.out.println(\"\\t\\t3. 修 改 学 生\"); System.out.println(\"\\t\\t4. 查 看 学 生\"); System.out.println(\"\\t\\t5. 退 出 登 录\"); Scanner sc = new Scanner(System.in); System.out.print(\"请输入操作选项： \"); String num = sc.nextLine(); switch(num){ case \"1\": addStudent(array); break; case \"2\": removeSudent(array); break; case \"3\": changeStudent(array); break; case \"4\": selectStudent(array); break; case \"5\": System.out.println(\"退出登录\"); System.exit(0); default: System.out.println(\"请输入正确的操作\"); } } } public static void addStudent(ArrayList array){ System.out.println(\"------------------------------\"); String studentId; while (true){ Scanner id = new Scanner(System.in); System.out.print(\"请输入学号： \"); studentId = id.nextLine(); boolean flag = isId(array, studentId); if(flag){ System.out.println(\"学号存在，请重新输入\"); }else{ break; } } Scanner name = new Scanner(System.in); System.out.print(\"请输入名字： \"); String studentName = name.nextLine(); Scanner age = new Scanner(System.in); System.out.print(\"请输入年龄： \"); String studentAge = age.nextLine(); Scanner address = new Scanner(System.in); System.out.print(\"请输入居住地： \"); String studentAddress = address.nextLine(); Student s = new Student(); s.setId(studentId); s.setName(studentName); s.setAge(studentAge); s.setAddress(studentAddress); array.add(s); System.out.println(\"学生添加成功\"); } public static void removeSudent(ArrayList array){ Scanner sc = new Scanner(System.in); System.out.print(\"请输入你要删除的学号： \"); String id = sc.nextLine(); boolean flag = isId(array, id); if (flag) { for (int i = 0; i array){ Scanner sc_1 = new Scanner(System.in); System.out.print(\"请输入要修改的学号： \"); String studentId = sc_1.nextLine(); boolean flag = isId(array, studentId); if(flag){ Scanner name = new Scanner(System.in); System.out.print(\"请输入名字： \"); String studentName = name.nextLine(); Scanner age = new Scanner(System.in); System.out.print(\"请输入年龄： \"); String studentAge = age.nextLine(); Scanner address = new Scanner(System.in); System.out.print(\"请输入居住地： \"); String studentAddress = address.nextLine(); Student s = new Student(); s.setId(studentId); s.setName(studentName); s.setAge(studentAge); s.setAddress(studentAddress); for (int i = 0; i array){ if (array.size() == 0){ System.out.println(\"无数据，请添加数据~~~\"); }else { System.out.println(\"\\t学号\\t\\t\\t\\t姓名\\t\\t年龄\\t\\t居住地\"); for (int i = 0; i array, String id){ boolean flag = false; for (int i = 0; i "},"NoteBook/java基础/方法和构造方法.html":{"url":"NoteBook/java基础/方法和构造方法.html","title":"方法和构造方法","keywords":"","body":"方法 就是将具有独立功能关系的代码块组织成为一个整体，使其具有特殊功能的代码集 方法必须创建才可以使用，该过程是方法定义 方法创建后并不直接运行的，需要手动使用后才执行，该过程称为方法调用 方法的定义 public static void 方法名字(){ // 方法体 } public static void homeStudent(){ // 方法体 } 方法的调用 方法名(); homeStudent(); 案例 public class Demo7 { public static void main(String[] args) { isEvenNumber(2434234); } public static void isEvenNumber(int number) { if (number % 2 == 0){ System.out.println(\"是偶数\"); }else{ System.out.println(\"不是偶数\"); } } } 方法的通用格式 public static 返回值类型 方法名(参数){ // 方法体; return 数据; } public static：修饰符，目前记住这个格式 返回值类型：方法操作完毕后返回的数据的数据类型，如果方法操作完毕，没有数据返回，这里写void，而且方法体中不写return 方法名：调用方法时使用的标识 参数：由数据类型和变量名组成，多个参数之间用逗号隔开 方法体：完成功能的代码块 return：如果方法操作完毕，有数据返回，用于把数据返回给调用者 明确返回值类型 明确方法操作完毕之后是否有数据返回，如果没有写void，如果有，写对应的数据类型 明确参数 明确参数的类型何数量 方法调用 void直接调用即可，非void类型的方法，推荐使用变量接受调用 方法的重载 方法重载值同一个类中定义的多个方法之间的关系，满足下列条件的万多个方法构成重载 条件 多个方法在同一个类中 多个方法具有相同的方法名 多个方法的参数不相同，类型不同或者数量不同 特点 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式 重载仅针对同一个类种方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载 案例 public static void main(String[] args) { int a = num(1, 2); System.out.println(a); int b = num(1, 2, 3); System.out.println(b); } public static int num(int num1, int num2){ return num1 + num2; } public static int num(int num1, int num2, int num3){ return num1 + num2 + num3; } 运行结果： 3 6 方法参数传递 基本类型 对于基本数据类型的参数，形式参数的改变，不影响实际参数的值 public static void main(String[] args) { int number = 100; System.out.println(\"调用方法前\" + number); change(number); System.out.println(\"调用方法后\" + number); } public static void change(int number){ number = 200; } 运行结果： 调用方法前100 调用方法后100 引用类型 对于引用类型的参数，形式参数的改变，影响实际参数的值 public static void main(String[] args) { int[] arr = {1, 2, 3}; System.out.println(\"调用方法前\" + arr[1]); change(arr); System.out.println(\"调用方法后\" + arr[1]); } public static void change(int[] number){ number[1] = 123; } 运行结果： 调用方法前2 调用方法后123 方法注意事项 方法不能嵌套 public static void isEvenNumber(){}中的void是不返回值，可以省略return，也可以写单独的return，后面不加数据 方法名前面的类型要和方法里面定义的数据类型保持一致 构造方法 构造方法是一种特殊的方法 作用 创建对象 功能 完成对象数据的初始化 public class 类名{ 修饰符 类名 (参数) { // 注意：构造方法的类名要大写 } } public class Student{ public Student (){ } } "},"NoteBook/java基础/Array数组.html":{"url":"NoteBook/java基础/Array数组.html","title":"Array","keywords":"","body":"Array数组 一次性声明大量的用于存储数据的变量，要存储的数据通常都是同类型 就是一种用于存储多个相同类型数据的存储模型 定义格式 数据类型[] 变量名 int[] arr 定义了一个int类型的数组，数组名是arr 数据类型 变量名[] int arr[] 定义了一个int类型的变量arr数组 初始化 动态初始化 初始化时只指定长度，由系统为数组分配初始值 格式 数据类型 [] = new 数据类型[数据长度]; int[] arr = new int[3]; 左边： int：说明数组中的元素是int类型 []：说明这是一个数组 arr：这是数组的名称 右边： new：为数组申请内存空间 int：说明数组中的类型是int类型 []：说明这是一个数组 3：说明数组中的个数或者是数组长度 静态初始化 初始化时指定每个数组元素的初始值，由系统决定暑数组长度 格式 数据类型[] 变量名 = new 数据类型[]{数据1, 数据2, 数据3, 数据4, ……}; int[] arr = new int[]{1, 2, 3, 4, ……}; 简化格式 数据类型[] 变量名 = {数据1, 数据2, 数据3, ……}; int[] arr = {1, 2, 3, 4, ……}; 内存分配 数组在初始化时，会为存储空间添加默认值 整数：默认值0 浮点数：默认值0.0 布尔值：默认值是false 字符：默认值是空字符 引用数据类型：默认值是null 栈内存 存储局部变量 定义在方法中的变量，例如arr，使用完毕，立即消失 基本数据变量 对象的引用 堆内存 存储new出来的内容（实体、对象） 数组操作 遍历 int[] arr = {11, 22, 33, 44}; for (int i = 0 ; i Arrays类 工具类 构造方法用private修饰 【为了防止外界创建对象】 成员用 public static 修饰【使用类名访问该成员方法】 方法名 说明 Arrays.toString(int[] a)； 返回指定数组的内容的字符串形式 Arrays.sort(int[] a)； 按照数字顺序排列指定的数组 import java.util.Arrays; public class Test2 { public static void main(String[] args){ int[] arr = {21, 11, 4, 9}; System.out.println(Arrays.toString(arr)); Arrays.sort(arr); System.out.println(Arrays.toString(arr)); } } "},"NoteBook/java基础/String.html":{"url":"NoteBook/java基础/String.html","title":"String","keywords":"","body":"String 字符串 字符串的特点 字符串不可变，它们的值在创建后不能被更改 虽然String的值是不可变的，但是它们可以被共享 字符串效果上相当于字符串数组（char[]），但是底层原理是字节数组（byte[]） String的构造方法 创建一个空白字符串对象，不包含任何内容 String s1 = new String(); 根据字符数组的内容，来创建字符串对象 char[] str = {'a', 'b', 'c'}; String s2 = new String(str); 根据字节数组的内容，来创建字符串对象 byte[] bytes = {97, 98, 99}; String s3 = new String (bytes); 直接赋值的方式创建字符串对象 String str = \"abc\"; String 特点 以 \" \" 方式给出的字符串，只要字符序列相同（顺序和大小写），无论在程序代码中出现几次，JVM都会建立一个String对象，并在字符串池中维护 String 操作方法 toString() 返回对象的字符串表示形式，建议子类重写该方法 alt + ins ——> toString() equals() 比较对象是否相等，默认的也是比较地址，也需要重写 == 相比较是比较的是两个类的地址是否一样 equals()比较的是两个类的内容是否一样（需要重写） 测试类 public static void main(String[] args){ Test test1 = new Test(\"Mpy\", \"20\"); Test test2 = new Test(\"Mpy\", \"20\"); // 创建两个对象相比较 System.out.println(test1.equals(test2)); } 方法重写 public class Test { private String name; private String age; public Test(){} public Test(String name, String age) { this.name = name; this.age = age; } public String getName() { return name; } public String getAge() { return age; } public void setName(String name) { this.name = name; } public void setAge(String age) { this.age = age; } // 重写toString方法 @Override public String toString() { return \"Test{\" + \"name='\" + name + '\\'' + \", age='\" + age + '\\'' + '}'; } // 重写equals方法 @Override public boolean equals(Object o){ // this —— 代表的是test1 // o —— 代表的是test2 if (this == o){ // 比较两者的地址是否一样，一样直接返回true return true; } if (o == null || getClass() != o.getClaass()){ // 先比较test.equals(test1)中的test1是否为空，在比较两个对象是否来自同一个类 return false; } Test test = (Test) o; // 向下强转，可以让test1.age和test2.age可以进行比较 if (age != test.age){ // 这里的age是this.age也就是test1的age，而后面的test是刚刚强转后的，可以访问自己的变量 return false; } // name不等于null，之后调用String的equals方法进行比较 return name != null ? name.equals(test.name) : test.name == null; } } charAt() 用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。 字符串的遍历 public static void main(String[] args) { String str = \"abcdefghijklmnopqresuvwxyz\"; for (int i = 0; i 案例 字符串的统计 public class Demo{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); String str_1 = sc.nextline(); int big = 0; int small = 0; int number = 0; for(int i = 0; i = 'A' && ch = 'a' && ch = '0' && ch 字符串的比较 利用== equals()，将此字符串与指定的字符串相比较（s1.equals(s2） 字符串的拼接 package demo1; import java.util.Scanner; public class Demo1 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String str_1 = sc.nextLine(); String str_2 = \"\"; str_2 += \"[\"; for (int i = 0; i 字符串的旋转 package demo1; import java.util.Scanner; public class Demo8 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); String ss = reverse(s); System.out.println(ss); } public static String reverse(String str){ String str_1 = \"\"; for (int i = str.length() - 1; i >= 0 ; i --){ str_1 += str.charAt(i); } return str_1; } } StringBuilder String 与StringBuilder String内容是不可变的 StringBuilder内容是可变的 构造方法 创建一个空白可变字符串对象，不含任何内容 StringBuilder ss = new StringBuilder(); 根据字符串的内容，来创建可变字符串 对象 StringBuilder ss = new StringBuilder(\"hello\"); String和StringBuilder转换 String Builder转String 通过toString()就可以实现把String Builder转换成String package demo2; public class Demo1 { public static void main(String[] args) { StringBuilder s1 = new StringBuilder(); s1.append(\"hello \").append(\"world\"); System.out.println(s1); String s2 = s1.toString(); System.out.println(s2); } } String转StringBuilder 通过构造方法就可以实现吧String转换成String Builder package demo2; public class Demo1 { public static void main(String[] args) { String s3 = \"you is sb\"; StringBuilder s4 = new StringBuilder(s3); System.out.println(s4); } } 数组的转换（数组按照StringBuilder输出在按照String返回） public class Demo2 { public static void main(String[] args) { int[] arr = {1, 2, 3, 4}; String s1 = arrayToString(arr); System.out.println(s1); } public static String arrayToString(int[] arr){ StringBuilder str = new StringBuilder(); str.append(\"[\"); for (int i = 0; i 字符串的翻转（String转StringBuilder，调用reverse，再转String） package demo2; import java.util.Scanner; public class Demo3 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); StringBuilder str1 = new StringBuilder(str); str1.reverse(); String str2 = str1.toString(); System.out.println(str2); } } 简易版本 import java.util.Scanner; public class Demo3 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); String s = reverse(str); System.out.println(s); } public static String reverse(String s){ return new StringBuilder(s).reverse().toString(); } } "},"NoteBook/java基础/类和对象.html":{"url":"NoteBook/java基础/类和对象.html","title":"类和对象","keywords":"","body":"类和对象 类 什么是类 类是对现实生活中一类具有共同属性和行为的事物的抽象 特点 类是对象的数据类型 类是具有相同属性和行为的一组对象的集合 什么是对象 是能够看看得到摸得着的真实存在的实体 对象的属性 对象具有的各种特征，每个对象的每个属性都拥有特定的值 如：品牌 : 小米 对象的行为 对象能够执行的操作 两者的关系 类是对象的抽象 对象是类的实体 Object类 Object是类层次结构的根，每个类都可以将Object作为超类，所有类都直接或者间接的继承自该类 类的定义 属性和行为构成 属性：在类中通过成员变量来体现（类中方法外的变量） 行为：在类中通过成员方法来体现（和以前的的方法相比去掉static关键字即可） 如何定义 public class 类名 { // 成员变量 变量1的数据类型 变量1; 变量2的数据蕾西 变量2; // 成员方法 （这里的成员方法是没有static的） 方法1; 方法2; } public class Phone{ String brand; int price; public void call(){ System.out.println(\"打电话\"); } public void sendMessage(){ System.out.println(\"发短信\"); } } 标准类的创建 成员变量 使用private修饰 构造方法 提供一个无参数构造 提供一个多参数构造 成员方法 提供每一个成员变量对应的setXxx()/getXxx() 提供一个现实对象信息的show() 创建对象并为其成员变量赋值的两种方式 无参构造方法创建对象后使用setXxx()赋值 使用带参数构造方法直接创建带有属性值的对象 对象 对象的创建 类名 对象名 = new 类名(); Phone p = new Phone(); 对象的使用 使用成员变量 对象名.变量名 p.brand 使用成员方法 对象名.方法名() p.call() "},"NoteBook/java基础/包.html":{"url":"NoteBook/java基础/包.html","title":"包","keywords":"","body":"包 包的创建 包其实就是文件夹 作用 对类进行分类管理 定义格式 package 包名;（多级包用\".\"分开） package com.it.ytr; 包的创建 手动创建包 创建文件夹 自动创包 javac -d .HelloWorld.java 包的导入 import 包的路径.类名 import java.util.Scanner "},"NoteBook/java基础/修饰符.html":{"url":"NoteBook/java基础/修饰符.html","title":"修饰符","keywords":"","body":"修饰符 权限修饰符 修饰符 同一个类中 同一个包中不管子类无关类 不同包的子类 不同包的无关类 private T 默认 T T protected T T T public T T T T 状态修饰符 类型限定：顾名思义就是用来限定变量的类型（注意不是数据类型），被其修饰的变量有如下特性： 类 方法 变量 static 内部类，让其可以直接实例化 类方法，不需要实例对象就可调用 类成员，所有实例对象共享 final 不可继承，即没有子类 不可重写 不可修改 abstract 不能实例化，即使用必继承 无实现，子类必须实现 —————— transient —————— —————— 无需序列化 volatile —————— —————— 多线程 final ﬁanl关键字的作用 ﬁnal代表最终的意思，可以修饰成员方法，成员变量，类 ﬁnal修饰类、方法、变量的效果 ﬁanl修饰类：该类不能被继承（不能有子类，但是可以有父类） ﬁnal修饰方法：该方法不能被重写 ﬁnal修饰变量：表明该变量是一个常量，不能再次赋 final修饰局部变量 修饰基本数据类型 final修饰指的是基本数据类型的数据值不能发生改变 修饰引用类型变量 final修饰指的是引用数据类型的地址值不能发生改变，但是地址里面的内容是可以发生改变的 static static关键字的意思是静态，可以修饰成员方法、成员变量 特点 被类的所有对象共享 这也是我们判断是否使用静态关键字的条件 可以通过类名调用 当然，也可以通过对象名调用 Student类 public class Student { public String name; public int age; public static String school; // 定义成共享成员变量 public void show(){ System.out.println(name + \", \" + age + \", \" + school); } } - 测试类 ```java public class Demo1 { public static void main(String[] args) { Student.school = \"山西职业技术学院\"; // 类名调用 Student s1 = new Student(); s1.name = \"Mpy\"; s1.school=\"山西职业技术学院\"; // 对象名调用 s1.age = 10; s1.show(); Student s2 = new Student(); s2.name = \"Mps\"; s2.age = 12; s2.show(); } } ``` 非静态成员方法 能访问静态的成员变量 能访问非静态的成员变量 能访问静态的成员方法 能访问非静态的成员方法 静态的成员方法 能访问静态的成员变量 能访问静态的成员方法 静态方法只能访问静态成员 "},"NoteBook/java基础/抽象类.html":{"url":"NoteBook/java基础/抽象类.html","title":"抽象类","keywords":"","body":"抽象类（abstract） 一个没有方法体的方法应该被定义为抽象方法，而类中如果没有抽象方法，该类必须定义为抽象类 举例 public abstract class Demo{ // 定义抽象类 public abstract void eat(); // 定义抽象方法 } 特点 抽象类特点 抽象类和抽象方法必须使用abstract关键字修饰 public abstract class Demo{} // 抽象类 public abstract coid eat(); // 抽象方法 抽象类中不一定有抽象方法，但抽象方法中一定是抽象类 抽象类实例化？ 参照多态，通过子类对象实例化，这叫抽象类多态 抽象类的子类 要么是重写抽象类中的所有抽象方法 要么子类就是抽象类 抽象类成员特点 成员变量 可以使变量 也可以是常量（final修饰） 构造方法 有构造方法，但是不能实例化 用子类访问父类数据的初始化 成员方法 可以是抽象方法：限定子类必须完成某些动作 也可以有非抽象方法：提高代码的复用性 案例 动物类（父类） public abstract class Animal { private String name; private String age; public Animal(){} public Animal(String name, String age){ this.name = name; this.age = age; } public abstract void eat(); public void setName(){ this.name = name; } public String getName(){ return name; } public void setAge(){ this.age = age; } public String getAge(){ return age; } } 猫类（子类） public class Cat extends Animal { public Cat() { } public Cat(String name, String age) { super(name, age); } @Override public void eat() { System.out.println(\"猫吃鱼\"); } } 狗类（子类） public class Dog extends Animal { public Dog() { } public Dog(String name, String age) { super(name, age); } @Override public void eat() { System.out.println(\"狗吃骨头\"); } } 测试类 public class Test { public static void main(String[] args) { Animal cat = new Cat(\"mmimi\", \"12\"); Animal dog = new Dog(\"beibei\", \"11\"); cat.eat(); dog.eat(); System.out.println(\"名字：\" + cat.getName() + \", 年龄：\" + cat.getAge()); System.out.println(\"名字：\" + dog.getName() + \", 年龄：\" + dog.getAge()); } } 运行结果 猫吃鱼 狗吃骨头 名字：mmimi, 年龄：12 名字：beibei, 年龄：11 "},"NoteBook/java基础/接口.html":{"url":"NoteBook/java基础/接口.html","title":"接口","keywords":"","body":"接口(implements) 特点 接口的特点 接口用关键字interface修饰 public interface 接口名 {} 类实现接口用implements表示 public class 类名 implements 接口名{} 接口的实例化和多态的实例化一样，通过；通过实现类对象实例化，这叫接口多态 多态的形式 具体类多态、抽象类多态、接口多态 多态的前提 有继承或者实现关系、有方法重写、有父(类/接口)引用指向(子/实现)类对象 接口的实现类 要么重写接口中的所有抽象方法 要么本身就是抽象类 接口的成员特点 成员变量 只能是常量 默认成员变量修饰符public static final 构造方法 接口没有构造方法 因为接口只要是对行为进行抽象的是没有具体存在的 一个类如果没有父类，默认继承自Object类 成员方法 只能是抽象方法 默认修饰符public abstract 类和接口的关系 类和类的关系 继承关系，只能单继承，但是可以多层继承 public class Demo1 extends Demo2{} 类和接口的关系 实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口 public class Demo1 extends Objects implements Demo2, Demo3, Demo4{} 接口和接口的关系 继承关系，可以单继承，也可以多继承 public interface Demo1 extends Demo2, Demo3{} 抽象类和接口的区别 成员区别 | 抽象类 | 接口 | | -------------------------------------------------- | -------------- | | 变量、常量、有构造方法、有抽象方法、也有非抽象方法 | 常量、抽象方法 | 关系区别 | 类与类 | 类与接口 | 接口与接口 | | ------------ | ------------------------------ | -------------------------- | | 继承，单继承 | 实现、可以单实现、也可以多实现 | 继承、单继承、多继承都可以 | 设计理念的区别 | 抽象类 | 接口 | | ------------------------ | ---------------------- | | 对类抽象，包括属性、行为 | 对行为抽象、主要是行为 | 类名作为形参和返回值 方法的形参是类名，其实需要的是该类的对象 方法的返回值是类名，其实返回的是该类的对象 "},"NoteBook/java基础/内部类.html":{"url":"NoteBook/java基础/内部类.html","title":"内部类","keywords":"","body":"内部类 就是在一个类中定义一个类，在一个A类内部定义一个类B，类B就成为内部类 格式 phblic class 类名{ 修饰符 class 类名{ } } public class Outer{ public class Inner{ } } 分类 在类的成员位置：成员内部类 外部类名.内部类名 对象名 = 外部类对象.内部类对象; 范例： Outer.Inner outi = new Outer().new Inner(); outi.show(); 成员内部类 正常的 public class Animal{ private String name = \"Mpy\"; public class Cat{ public void show(){ System.out.println(\"猫咪\" + name + \"岁了\"); } } } // 访问 Animal.Cat animal = new Animal().new Cat(); animal.show(); 匿名方法 public class Animal{ private String name = \"Mpy\"; private class Cat{ public void show(){ System.out.println(\"猫咪的名字是：\" + name); } } public void accessClass(){ Cat cat = new Cat(); cat.show(); } } // 访问 Animal cat = new Animal(); cat.accessClass(); 在类的局部位置：局部内部类 局部内部类实在方法中定义的类，所以在外界是无法直接使用的，需要在方法内部创建对象并使用该类可以直接访问外部类的成员，也可以访问方法内的局部变量 局部内部类 public class Demo1 { private int num = 10; public void method(){ class Demo2{ public void show(){ System.out.println(num); } } Demo2 demo2 = new Demo2(); demo2.show(); } } 测试类 public class Test { public static void main(String[] args) { Demo1 d = new Demo1(); d.method(); } } 匿名内部类（是局部内部类的一种特殊形式） 前提 存在一个类或接口，这里的类可以是具体类也可以是抽象类 格式 new 类名或接口(){ 重写方法; }; new Inter() { // 匿名对象 public void show() { } } 是一个继承了该类或实现了接口的子类匿名对象 案例1 接口 public interface Inter { void show(); } 测试 public class Test { public void method(){ new Inter(){ @Override public void show() { System.out.println(\"匿名内部类\"); } }.show(); // 但是要多次调用这个方法不能用这种方法 } Inter i = new Inter(){ @Override public void show() { System.out.println(\"匿名内部类\"); } }; i.show(); // 通过接口的实现类（或者类的子类对象） } public static void main(String[] args) { new Test().method(); } } 案例2 接口 public interface Inter(){ void jump(); } 接口方法 public class Test{ public void method(Inter inter){ inter.jump(); } } 测试类 public class Demo{ public static void (String[] args){ Test test = new Test(); test.method(new Inter(){ // 匿名类 @Override public void jump(){ System.out.println(\"猫可以跳高了\"); } }); } } "},"NoteBook/java基础/基本类型包装类.html":{"url":"NoteBook/java基础/基本类型包装类.html","title":"基本类型包装类","keywords":"","body":"基本类型包装类 将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作改数据 基本数据类型和字符串之间的转换 "},"NoteBook/面向对象/封装.html":{"url":"NoteBook/面向对象/封装.html","title":"封装","keywords":"","body":"封装 原则 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问成员变量private，提供对应的setXxx()/getXxx()方法 特点 通过方法来控制成员变量的操作，提高了代码的安全性 把代码进行封装，提高了代码的复用性 private 特点 是一个权限修饰符 可以修饰成员（成员方法和成员变量） 作用 保护成员不被别的类使用，被private修饰的成员只有在本类中才能访问 针对private修饰的成员变量，如果被其他类使用，提供相应的操作 提供get变量名()方法，用于获取成员变量的值，方法用public修饰 提供set变量名(参数)方法，用于设置成员变量的值，方法用public修饰 this指向 用this修饰的变量指代成员变量 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量 ```java public class Student { private String name; public void setName(String name){ } } public class Student { private String name; private int age; public void setName(String name){ name = name;（会显示null） this.name = name;（这里的this.name就是成员变量, 而后面的name就是形参定义的变量） } public void setAge(int age) { age = age;（会显示0） this.age = age;（这里的this.age就是成员变量, 而后面的age就是形参定义的变量） } public String getName(){ return name; } public int getAge(){ return age; } public void show(){ System.out.println(name + \", \" + age); } public static void main(String[] args) { Test4 t = new Test4(); // System.out.println(t.name); t.setName(\"qwe\"); t.setAge(12); t.show(); } } ``` "},"NoteBook/面向对象/继承.html":{"url":"NoteBook/面向对象/继承.html","title":"继承","keywords":"","body":"继承 继承是面向对象三大特征之一 可以使得子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法 继承的格式 public class 子类名(派生类) extends 父类名(基类、超类) {} public class Zi extends Fu {} 继承的特点 优点 提高了代码的复用性（多个类相同的成员可以放到同一个类中） 提高了代码的维护性（如果代码需要更改，修改一处即可） 缺点 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性 继承的关系 is a 苹果和水果、猫和动物，都是满足前者是后者的一种或是后者是前者的一种，存在继承关系 super 方法内变量——>成员变量——>父类成员变量 输出方法内都变量 System.out.println(age); 输出成员变量 System.out.println(this.age); 输出父类成员变量 System.out.println(super.age); super用法和this类似 this代表本类对象的引用 super代表父类对象的引用 | 关键字 | 访问成员变量 | 访问构造方法 | 访问成员方法 | | :----: | :--------------------------------: | :---------------------------: | :------------------------------------: | | this | this.成员变量访问本类成员变量 | this(……)访问本类构造方法 | this.成员方法(……)访问本类成员方法 | | super | super.成员变量访问父类成员变量 | super(……)访问父类构造方法 | super.成员方法(……)访问父类成员方法 | 继承中访问特点 访问构造方法 访问特点 子类中所有的构造方法默认都会访问父类中无参的构造方法 每一个子类构造方法的第一条语句默认是：super() 如果父类中没有无参构造方法，只有带参构造方法，如何解决？ 通过使用super关键字调用父类的有参数构造方法 在父类中创建一个无参数构造方法 父类（在父类中创建一个无参数的构造方法） package demo3; public class Fu { public Fu(){ // 这就是无参数的构造方法 System.out.println(\"输出无参数的父类\"); } public Fu(int id){ System.out.println(\"输出有参数的父类：\" + id); } } 子类（子类中添加调用父类有参数的构造方法） package demo3; public class Zi extends Fu { public Zi(){ System.out.println(\"输出无参数的子类\"); } public Zi(int id){ super(1); // 这里就是调用的地方 System.out.println(\"输出有参数的子类：\" + id); } } 测试 package demo3; public class Demo1 { public static void main(String[] args) { Zi zi = new Zi(1); } } 访问成员方法 子类范围寻找 父类范围寻找 还没有就报错（不考虑父亲的父亲，但是确实可以访问到父亲的父亲的方法） 方法的重写 概念 子类和父类中出现一样的方法声明 应用 当子类需要父类的功能，而功能主体子类有自己特有的内容时，可以重写父类中的方法，这样既有父类的功能，还有子类的功能 @Override 一个注解 帮助检查重写方法的方法声明的正确性 注意事项 父类中的私有方法，子类世继承不到的（private修饰的），也不可能重写 子类方法的访问权限不能更低（public > 默认 > 私有） 继承的注意 java不支持多继承，支持单继承 java中类支持多层继承 "},"NoteBook/面向对象/多态.html":{"url":"NoteBook/面向对象/多态.html","title":"多态","keywords":"","body":"多态 同一个对象，在不同时刻表现出来的不同形态 猫 猫 cat = new 猫(); 动物 animal = new 猫(); 这里猫在不同时刻表现出来了不同的形态，这就是多态 多态的前提和体现 有继承/实现关系 有方法重写 有父类引用指向子类对象 成员访问特点 成员变量：编译看左边，执行看左边 成员方法：编译看左边，执行看右边 成员方法有重写，而成员变量没有 在定义方法的时候，使用父类型作为参数将他在使用的时候使用的是具体的子类类型参与操作 定义一个动物类 public class Animal{ public void static eat(){ System.out.println(\"动物吃食物\"); } } 定义一个子类(继承自动物类) public class Dog extends Animal { @Override public void eat() { System.out.println(\"狗吃骨头\"); } public void kanmen(){ System.out.println(\"狗看门\"); } } 操作类中的一个方法 public class CaoZuo { public void useAnimal(Animal a){ a.eat(); } } 测试 public class Demo1 { public static void main(String[] args) { CaoZuo cz = new CaoZuo(); Dog d = new Dog(); cz.useAnimal(d); // 可以调用 cz.kaamen(d); // 不能调用，编译看左边，左边是Animal类，类中没有kanmen这个方法，所以编译错误，不会执行 } } 这样使用多态，不会再创建一个子类就重新定义一个方法，直接让父类型作为参数接受子类型，构成多态，根据成员访问特点进行操作 优点 多态形式作为参数之后，提高了程序的扩展性 具体体现 定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类参与操作 缺点 不能通过多态的形式访问子类独特的方法 转型 可以帮助我们访问子类中独有的方法 向上转型 从子到父 父类引用指向子类对象 向下转型 解决了多态不能访问子类对象的方法问题 从父到子 父类引用转为子类对象 案例： 定义一个动物类 public class Animal { public void eat(){ System.out.println(\"动物吃食物\"); } } 定义一个猫类，继承自动物类 public class Cat extends Animal { @Override public void eat() { System.out.println(\"猫吃鱼\"); } public void sleep(){ System.out.println(\"猫咪要睡觉\"); } } 测试类 public class Demo1 { public static void main(String[] args) { Animal a = new Cat(); // 这是向上转型 a.eat(); a.sleep(); // 这个方法就不能执行，左边编译右边执行，左边没有sleep方法，无法编译成功 Cat c = (Cat) a; // 这个是向下转型，强制父类引用转为子类对象 c.sleep(); // 就可以使用了 } } "},"NoteBook/常用API/Random.html":{"url":"NoteBook/常用API/Random.html","title":"Random","keywords":"","body":"Random import java.util.Random; Random r = new Random(); int rs = r.nextInt(10); "},"NoteBook/常用API/Math.html":{"url":"NoteBook/常用API/Math.html","title":"Math","keywords":"","body":"Math 方法 说明 案例 Math.abs(int a) 返回参数的绝对值 System.out.println(Math.abs(12));System.out.println(Math.abs(-1)); Math.ceil(double a) 返回大于或等于参数的最小double值，等于一个整数 System.out.println(Math.ceil(12.34));System.out.println(Math.ceil(12.56)); Math.floor(double a) 返回小于或等于参数的最小double值，等于一个整数 System.out.println(Math.floor(12.34));System.out.println(Math.floor(12.56)); Math.round(float a) 按照四舍五入返回最接近参数的int System.out.println(Math.round(12.34L));System.out.println(Math.round(12.56L)); Math.max(int a, int b) 返回两个int数中最大的那个 System.out.println(Math.max(1, 3)); Math.min(int a, int b) 返回两个int数中最小的那个 System.out.println(Math.min(1, 2)); Math.pow(double a, double b) 返回a的b次幂的值 System.out.println(Math.pow(2.0, 3.0)); Math.random() 返回值为double的正值 System.out.println(Math.random());System.out.println((int)(Math.random()*100) + 1) // 1-100的随机数 "},"NoteBook/常用API/System.html":{"url":"NoteBook/常用API/System.html","title":"System","keywords":"","body":"System 方法 说明 案例 System.exit(int num) 退出java虚拟机int后面的额变量标识退出字符码 System.exit(0); System.currentTimeMillis() 返回从1970.1.1与现在的时间差（毫秒） System.out.println(System.currentTimeMillis() * 1.0 / 1000 / 60 / 60 / 24 / 365); long start = System.currentTimeMillis(); for (int i = 0; i "},"NoteBook/常用API/Scanner.html":{"url":"NoteBook/常用API/Scanner.html","title":"Scanner","keywords":"","body":"Scanner import java.util.Scanner; Scanner sc_2 = new Scanner(System.in); int num_2 = sc_2.nextInt(); "}}