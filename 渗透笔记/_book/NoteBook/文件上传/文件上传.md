核心：通过各种手段把文件上传上去

**黑名单【名单上的东西会拦截】**

**检测是否前端后端检测**

 前端验证可以利用抓包进行修改

**后缀替代**

- jsp、jsx、jspf都会被当作 jsp 执行
- asp、asa、cer、asps都会被当作 asp 执行
- php、php3、php4、php5、phtml都会被当作 php 执行
- exe、exee都会被当作 exe 执行

**修改文件类型**

上传php文件时，会要求匹配图片类型的，如果不符，上传失败

![](Image\图像 1.png)

**.htaccess绕过**

AddType application/x-httpd-php .jpg // jpg文件被当做php文件解析

**大小写绕过**

pHp phP Php

**空格绕过**

.php后面加一个空格 .php 

**小数点绕过**

1.php 1.php.

**::$DATA(Windows文件流)**

a.php => a.php::$DATA 两者是相互等价的 所以 上传a.php::$DATA

- **小技巧**

echo 123 > a.txt:1.txt 只会创建一个a.txt，没有1.txt，打开a.txt里面什么都没有，但是打开a.txt:1.txt就会看见里面的内容

**逻辑错误（只校验一次）**

php. . (先检测一次"."，在检验一次空格，最后剩下php.，也可以绕过)

**双写绕过**

pphphp (遇到发现php替换成空格，由于只检测了一次，剩下php了)

**白名单【名单上的会放行】**

**GET传参**

- **%00截断**

![](Image\图像 2.png)

%00截断只有在PHP5.3版本以下才会出现

![](Image\图像 3.png)

通过修改保存修改路径，后面添加php文件名加上%00进行截断，上传的图片本应该会按照代码直接移动到保存路径，例如192.168.30.250/uploads/1.php%00/asdas123.jpg，但是windows读到%00会认为结束了，不会考虑后面的，所以就把文件赋值到了1.php中

**POST传参**

- **00截断**

![](Image\图像 4.png)

POST传参想要进行截断%00是不能的（%00专属于GET请求），需要修改必修对其16进制进行修改

**GIF图片绕过**

- 利用GIF的前几行不会被重新渲染进行制作图片马

![](Image\图像 5.png)

**条件竞争**

- 先上传，之后移动，最后检测合格不合格（合格重新修改名字，不合格就删除）

- - 所以就出现了如果一个不停上传，一个不停访问，就会访问到上传上的文件

需要两个数据包

1. 访问上传的数据包

![](Image\图像 6.png)

1. 访问上传后图片位置的数据包

![](Image\图像 7.png)

之后进行跑数据包

- 上传包的线城是80、访问上传地址的数据包线程60